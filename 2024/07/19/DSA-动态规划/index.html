<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="dp这一块我一直觉得是算法里面比较难的一块, 思路千奇百怪. 虽然核心思路都是记录状态, 从前状态推后状态从而得出结果, 然而实际题目里面很多时候会有各种各样的问题, 比如递推关系抽象不出来, 又或者情况复杂导致判断多, 边界处理不当等等. 这几天稍微刷了刷dp, 简单记录. 题目分类来自: 灵茶山艾府-分享丨【题单】动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划分&#x2F;区间&#x2F;状压&#x2F;数位&#x2F;树形&#x2F;数据结构优化） 入门">
<meta property="og:type" content="article">
<meta property="og:title" content="DSA-动态规划">
<meta property="og:url" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="blacsheep&#39;s blog">
<meta property="og:description" content="dp这一块我一直觉得是算法里面比较难的一块, 思路千奇百怪. 虽然核心思路都是记录状态, 从前状态推后状态从而得出结果, 然而实际题目里面很多时候会有各种各样的问题, 比如递推关系抽象不出来, 又或者情况复杂导致判断多, 边界处理不当等等. 这几天稍微刷了刷dp, 简单记录. 题目分类来自: 灵茶山艾府-分享丨【题单】动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划分&#x2F;区间&#x2F;状压&#x2F;数位&#x2F;树形&#x2F;数据结构优化） 入门">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9key.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1594_1.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1594_2.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1594_3.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2435_1.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2435_2.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2435_3.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/174_1.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/329_1.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/329_2.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2328_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg">
<meta property="article:published_time" content="2024-07-19T07:53:51.000Z">
<meta property="article:modified_time" content="2024-07-20T14:26:38.890Z">
<meta property="article:author" content="blacsheep">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9key.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>DSA-动态规划</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/07/12/DSA%E6%B5%81%E7%A8%8B%E4%BC%98%E5%8C%96/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=DSA-动态规划"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=DSA-动态规划"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DSA-动态规划&body=Check out this article: http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=DSA-动态规划&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=DSA-动态规划"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%89%8D%E7%8A%B6%E6%80%81%E5%8A%A0%E5%88%B0%E5%90%8E%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">爬楼梯(前状态加到后状态)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-2466.-%E7%BB%9F%E8%AE%A1%E6%9E%84%E9%80%A0%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础: 2466. 统计构造好字符串的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-2266.-%E7%BB%9F%E8%AE%A1%E6%89%93%E5%AD%97%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">进阶: 2266. 统计打字方案数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.</span> <span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础: 198. 打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-3186.-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">进阶: 3186. 施咒的最大总伤害</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">基础: 53. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B61-918.-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">进阶1: 918. 环形子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B62-1191.-k-%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">进阶2: 1191. K 次串联后最大子数组之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%89%A9%E5%B1%95-152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">思路扩展: 152. 乘积最大子数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BCdp"><span class="toc-number">1.4.</span> <span class="toc-text">网格dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%82%B9%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础点的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">2684. 矩阵中移动的最大次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.4.3.</span> <span class="toc-text">2304. 网格中的最小路径代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%9E%E8%B4%9F%E7%A7%AF"><span class="toc-number">1.4.5.</span> <span class="toc-text">1594. 矩阵的最大非负积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.6.</span> <span class="toc-text">1301. 最大得分的路径数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%AB-k-%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.7.</span> <span class="toc-text">2435. 矩阵中和能被 K 整除的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="toc-number">1.4.8.</span> <span class="toc-text">174. 地下城游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.9.</span> <span class="toc-text">329. 矩阵中的最长递增路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.10.</span> <span class="toc-text">2328. 网格图中递增路径的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.11.</span> <span class="toc-text">2267. 检查是否有合法括号字符串路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">1.4.12.</span> <span class="toc-text">1937. 扣分后的最大得分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83-ii"><span class="toc-number">1.4.13.</span> <span class="toc-text">1463. 摘樱桃 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83"><span class="toc-number">1.4.14.</span> <span class="toc-text">741. 摘樱桃</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        DSA-动态规划
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">blacsheep</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-07-19T07:53:51.000Z" class="dt-published" itemprop="datePublished">2024-07-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>dp这一块我一直觉得是算法里面比较难的一块, 思路千奇百怪. 虽然核心思路都是记录状态, 从前状态推后状态从而得出结果, 然而实际题目里面很多时候会有各种各样的问题, 比如递推关系抽象不出来, 又或者情况复杂导致判断多, 边界处理不当等等. 这几天稍微刷了刷dp, 简单记录.</p>
<p>题目分类来自: <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tXLS3i/">灵茶山艾府-分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化）</a></p>
<h1 id="入门">入门</h1>
<h2 id="爬楼梯前状态加到后状态">爬楼梯(前状态加到后状态)</h2>
<h3 id="基础-2466.-统计构造好字符串的方案数">基础: 2466. 统计构造好字符串的方案数</h3>
<p>给你整数 zero ，one ，low 和 high ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ul>
<li>将 '0' 在字符串末尾添加 <code>zero</code> 次。<br />
</li>
<li>将 '1' 在字符串末尾添加 <code>one</code> 次。</li>
</ul>
<p>以上操作可以执行任意次。</p>
<p>如果通过以上过程得到一个 长度 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <code>好</code> 字符串。</p>
<p>请你返回满足以上要求的 不同 好字符串数目。由于答案可能很大，请将结果对 10^9 + 7 取余 后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">    输出：8</span><br><span class="line">    解释：</span><br><span class="line">    一个可能的好字符串是 &quot;011&quot; 。</span><br><span class="line">    可以这样构造得到：&quot;&quot; -&gt; &quot;0&quot; -&gt; &quot;01&quot; -&gt; &quot;011&quot; 。</span><br><span class="line">    从 &quot;000&quot; 到 &quot;111&quot; 之间所有的二进制字符串都是好字符串。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：low = 2, high = 3, zero = 1, one = 2</span><br><span class="line">    输出：5</span><br><span class="line">    解释：好字符串为 &quot;00&quot; ，&quot;11&quot; ，&quot;000&quot; ，&quot;110&quot; 和 &quot;011&quot; 。</span><br></pre></td></tr></table></figure>
<p>爬楼梯问题, 在上一次的基础上爬zero或者one个台阶.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countGoodStrings</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, zero: <span class="built_in">int</span>, one: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        lst = [zero, one]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> lst:</span><br><span class="line">                <span class="keyword">if</span> i&gt;=num:</span><br><span class="line">                    dp[i] += dp[i-num] % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">if</span> low&lt;=i&lt;=high:</span><br><span class="line">                ans += dp[i] % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> ans % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="进阶-2266.-统计打字方案数">进阶: 2266. 统计打字方案数</h3>
<p>Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。</p>
<p><img src="9key.png" /></p>
<p>为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。</p>
<p>比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母 'k' 。</p>
<p>注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice<strong>不</strong>使用它们。</p>
<p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。</p>
<p>比方说，Alice 发出的信息为 "bob" ，Bob 将收到字符串 "2266622" 。</p>
<p>给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。</p>
<p>由于答案可能很大，将它对 10^9 + 7 取余 后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：pressedKeys = &quot;22233&quot;</span><br><span class="line">    输出：8</span><br><span class="line">    解释：</span><br><span class="line">    Alice 可能发出的文字信息包括：</span><br><span class="line">    &quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot; 和 &quot;ce&quot; 。</span><br><span class="line">    由于总共有 8 种可能的信息，所以我们返回 8 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：pressedKeys = &quot;222222222222222222222222222222222222&quot;</span><br><span class="line">    输出：82876089</span><br><span class="line">    解释：</span><br><span class="line">    总共有 2082876103 种 Alice 可能发出的文字信息。</span><br><span class="line">    由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。</span><br></pre></td></tr></table></figure>
<p>9键输入转可能输出. 反向爬楼梯, 读到连续k个输入的时候每次下个输入都可以建立在合法的k-1,k-2,k-3上(如果为79还有k-4).</p>
<p>针对79和其他输入, 我们分three_stack和four_stack, 检测连续输入, 做叠加即可获取长度为n的连续同字符输入. 然后不同group做乘积即可.</p>
<p>当然, 由于同字符连续输入的输出可能数量总相同, 所以可以预处理先算出所有可能数量, 然后直接统计连续字符数去查询结果就行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countTexts</span>(<span class="params">self, pressedKeys: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        three_stack = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        four_stack = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(pressedKeys)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">while</span> i != n-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> pressedKeys[i] != pressedKeys[i+<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pressedKeys[i] <span class="keyword">in</span> <span class="string">&#x27;79&#x27;</span>:</span><br><span class="line">                stack = four_stack.copy()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack = three_stack.copy()</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> pressedKeys[i] == pressedKeys[i+<span class="number">1</span>]:</span><br><span class="line">                sum_ = <span class="built_in">sum</span>(stack) % mod</span><br><span class="line">                stack.pop(<span class="number">0</span>)</span><br><span class="line">                stack.append(sum_)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            start *= stack[-<span class="number">1</span>]</span><br><span class="line">            start %= mod</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<h2 id="打家劫舍">打家劫舍</h2>
<h3 id="基础-198.-打家劫舍">基础: 198. 打家劫舍</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：[1,2,3,1]</span><br><span class="line">    输出：4</span><br><span class="line">    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">        偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：[2,7,9,3,1]</span><br><span class="line">    输出：12</span><br><span class="line">    解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">        偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<p>每次偷窃与否基于前两个状态. 即 <code>f(n+1) = max(f(n),f(n-1)+value[n+1])</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="built_in">max</span>(nums[i-<span class="number">1</span>], nums[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> nums[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="进阶-3186.-施咒的最大总伤害">进阶: 3186. 施咒的最大总伤害</h3>
<p>一个魔法师有许多不同的咒语。</p>
<p>给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。</p>
<p>已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。</p>
<p>每个咒语最多只能被使用 一次 。</p>
<p>请你返回这个魔法师可以达到的伤害值之和的 最大值 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：power = [1,1,3,4]</span><br><span class="line">    输出：6</span><br><span class="line">    解释：</span><br><span class="line">    可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：power = [7,1,6,6]</span><br><span class="line">    输出：13</span><br><span class="line">    解释：</span><br><span class="line">    可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。</span><br></pre></td></tr></table></figure>
<p>首先最先看到是长度为3的打家劫舍, 初始思路可以直接找到最小值和最大值, 然后遍历一遍过去, 当打家劫舍来处理即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTotalDamage</span>(<span class="params">self, power: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_ = <span class="built_in">min</span>(power)</span><br><span class="line">        max_ = <span class="built_in">max</span>(power)</span><br><span class="line">        ctr = Counter(power)</span><br><span class="line"></span><br><span class="line">        score = [ctr[min_]*min_, ctr[min_+<span class="number">1</span>]*(min_+<span class="number">1</span>), ctr[min_+<span class="number">2</span>]*(min_+<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">if</span> max_-min_+<span class="number">1</span> &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(score)</span><br><span class="line">        dp = [score[<span class="number">0</span>], <span class="built_in">max</span>(score[<span class="number">0</span>],score[<span class="number">1</span>]), <span class="built_in">max</span>(score[:<span class="number">3</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, max_-min_+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">1</span>], dp[<span class="number">2</span>], <span class="built_in">max</span>(dp[<span class="number">0</span>]+ctr[min_+i]*(min_+i), dp[<span class="number">1</span>], dp[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>非常直观, 但是很可惜这么写会直接TLE. 因为从min到max这中间计算了太多无用状态, 优化解法为调用counter, 排序key, 然后依序读取key来处理(流程优化, 其实也就是将中间数值为0的部分做直接传递而非逐步计算).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTotalDamage</span>(<span class="params">self, power: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ctr = Counter(power)</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        dp = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(ctr):</span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                prev = k</span><br><span class="line">                dp[-<span class="number">1</span>] = k*ctr[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> k == prev + <span class="number">1</span>:</span><br><span class="line">                    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">1</span>], dp[<span class="number">2</span>], <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">2</span>], dp[<span class="number">0</span>] + k*ctr[k])</span><br><span class="line">                <span class="keyword">elif</span> k == prev + <span class="number">2</span>:</span><br><span class="line">                    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">2</span>], dp[<span class="number">2</span>], <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>]+k*ctr[k])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">2</span>], dp[<span class="number">2</span>], dp[<span class="number">2</span>] + k*ctr[k]</span><br><span class="line">                prev = k</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="最大子数组和">最大子数组和</h2>
<p>核心部分kadane算法, 即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curr = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">    curr = <span class="built_in">max</span>(curr,<span class="number">0</span>) + i</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, curr)</span><br></pre></td></tr></table></figure>
<h3 id="基础-53.-最大子数组和">基础: 53. 最大子数组和</h3>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组是数组中的一个连续部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">    输出：6</span><br><span class="line">    解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：nums = [1]</span><br><span class="line">    输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：nums = [5,4,-1,7,8]</span><br><span class="line">    输出：23</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            curr = <span class="built_in">max</span>(curr+i, i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="进阶1-918.-环形子数组的最大和">进阶1: 918. 环形子数组的最大和</h3>
<p>给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。</p>
<p>环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。</p>
<p>子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % n == k2 % n 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：nums = [1,-2,3,-2]</span><br><span class="line">    输出：3</span><br><span class="line">    解释：从子数组 [3] 得到最大和 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：nums = [5,-3,5]</span><br><span class="line">    输出：10</span><br><span class="line">    解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：nums = [3,-2,2,-3]</span><br><span class="line">    输出：3</span><br><span class="line">    解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</span><br></pre></td></tr></table></figure>
<p>掌握思路就很简单, 两种可能:</p>
<ol type="1">
<li>找中间部分最大(kadane)<br />
</li>
<li>最大部分为尾串+首串; 又由于数组大小总数一定, 即找到中间部分最小的字串, 依旧是kadane.</li>
</ol>
<h3 id="进阶2-1191.-k-次串联后最大子数组之和">进阶2: 1191. K 次串联后最大子数组之和</h3>
<p>给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。</p>
<p>例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。</p>
<p>返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。</p>
<p>由于 结果可能会很大，需要返回的 10^9 + 7 的 模 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：arr = [1,2], k = 3</span><br><span class="line">    输出：9</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：arr = [1,-2,1], k = 5</span><br><span class="line">    输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：arr = [-1,-2], k = 7</span><br><span class="line">    输出：0</span><br></pre></td></tr></table></figure>
<p>情况拆分, <code>k == 1</code>直接kadane即可; 一旦k大于1, 那么如果arr总和大于0, 那么我们一定会尽可能多读, 相当于kadane(arr+arr)+(k-2) * sum, 反之如果arr总和小于0, 那么我们直接对两个arr做kadane即可, 相当于kadane(arr+arr).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kConcatenationMaxSum</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">1</span>:</span><br><span class="line">            arr = arr + arr</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            curr = <span class="built_in">max</span>(curr, <span class="number">0</span>) + i</span><br><span class="line">            ans = <span class="built_in">max</span>(curr, ans)</span><br><span class="line">        <span class="keyword">return</span> (ans + (k&gt;<span class="number">1</span> <span class="keyword">and</span> sum_ &gt; <span class="number">0</span>) * (k-<span class="number">2</span>) * sum_) % mod</span><br></pre></td></tr></table></figure>
<h3 id="思路扩展-152.-乘积最大子数组">思路扩展: 152. 乘积最大子数组</h3>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">    输入: nums = [2,3,-2,4]</span><br><span class="line">    输出: 6</span><br><span class="line">    解释: 子数组 [2,3] 有最大乘积 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">    输入: nums = [-2,0,-1]</span><br><span class="line">    输出: 0</span><br><span class="line">    解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>
<p>掌握思路就简单, 读入小于0的时候用最小值来获取最大值, 读入大于0用最大值获取最大值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curr_min = <span class="number">1</span></span><br><span class="line">        curr_max = <span class="number">1</span></span><br><span class="line">        ans_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                curr_min, curr_max = <span class="built_in">min</span>(curr_min * i, i), <span class="built_in">max</span>(curr_max * i, i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr_min, curr_max = <span class="built_in">min</span>(curr_max * i, i), <span class="built_in">max</span>(curr_min * i, i)</span><br><span class="line">            ans_max = <span class="built_in">max</span>(curr_max, ans_max)</span><br><span class="line">        <span class="keyword">return</span> ans_max</span><br></pre></td></tr></table></figure>
<h2 id="网格dp">网格dp</h2>
<p>主要是网格移动相关.</p>
<h3 id="基础点的">基础点的</h3>
<h3 id="矩阵中移动的最大次数">2684. 矩阵中移动的最大次数</h3>
<p>给你一个下标从 0 开始、大小为 m x n 的矩阵 grid ，矩阵由若干 正 整数组成。</p>
<p>你可以从矩阵第一列中的 任一 单元格出发，按以下方式遍历 grid ：</p>
<p>从单元格 (row, col) 可以移动到 (row - 1, col + 1)、(row, col + 1) 和 (row + 1, col + 1) 三个单元格中任一满足值 严格 大于当前单元格的单元格。</p>
<p>返回你在矩阵中能够 移动 的 最大 次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]</span><br><span class="line">    输出：3</span><br><span class="line">    解释：可以从单元格 (0, 0) 开始并且按下面的路径移动：</span><br><span class="line">    - (0, 0) -&gt; (0, 1).</span><br><span class="line">    - (0, 1) -&gt; (1, 2).</span><br><span class="line">    - (1, 2) -&gt; (2, 3).</span><br><span class="line">    可以证明这是能够移动的最大次数。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：grid = [[3,2,4],[2,1,9],[1,1,7]]</span><br><span class="line">    输出：0</span><br><span class="line">    解释：从第一列的任一单元格开始都无法移动。</span><br></pre></td></tr></table></figure>
<p>老实说我觉得这更像一个遍历的题而不是dp的题. 当dp的话就检测每一列的可以到达点, 然后下一轮继续. 我当时写的一个O(m*n)时间带剪枝+O(1)空间的dp.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxMoves</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = -grid[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            found = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="comment"># j,i</span></span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> -<span class="number">1</span> &lt; grid[j][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j+<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span>:</span><br><span class="line">                        grid[j][i] = - grid[j][i]</span><br><span class="line">                        found = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j == m-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> -<span class="number">1</span> &lt; grid[j][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j-<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span>:</span><br><span class="line">                        grid[j][i] = - grid[j][i]</span><br><span class="line">                        found = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> -<span class="number">1</span> &lt; grid[j][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j+<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j-<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span>:</span><br><span class="line">                        grid[j][i] = - grid[j][i]</span><br><span class="line">                        found = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> found == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="网格中的最小路径代价">2304. 网格中的最小路径代价</h3>
<p>给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x &lt; m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。</p>
<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。</p>
<p>grid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</span><br><span class="line">    输出：17</span><br><span class="line">    解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。</span><br><span class="line">    - 路径途经单元格值之和 5 + 0 + 1 = 6 。</span><br><span class="line">    - 从 5 移动到 0 的代价为 3 。</span><br><span class="line">    - 从 0 移动到 1 的代价为 8 。</span><br><span class="line">    路径总代价为 6 + 3 + 8 = 17 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]</span><br><span class="line">    输出：6</span><br><span class="line">    解释：</span><br><span class="line">    最小代价的路径是 2 -&gt; 3 。 </span><br><span class="line">    - 路径途经单元格值之和 2 + 3 = 5 。 </span><br><span class="line">    - 从 2 移动到 3 的代价为 1 。 </span><br><span class="line">    路径总代价为 5 + 1 = 6 。</span><br></pre></td></tr></table></figure>
<p>描述复杂得要死, 实际就是个暴力, O(m*n^2).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathCost</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], moveCost: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [grid[<span class="number">0</span>][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp = [grid[i][k] + <span class="built_in">min</span>([dp[j] + moveCost[grid[i-<span class="number">1</span>][j]][k] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="进阶">进阶</h3>
<p>整体来说还是有一些难度的, 前面可能一眼看穿秒秒秒, 后面慢慢难度就上来了.</p>
<h3 id="矩阵的最大非负积">1594. 矩阵的最大非负积</h3>
<p>给你一个大小为 m x n 的矩阵 grid 。最初，你位于左上角 (0, 0) ，每一步，你可以在矩阵中 向右 或 向下 移动。</p>
<p>在从左上角 (0, 0) 开始到右下角 (m - 1, n - 1) 结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>
<p>返回 最大非负积 对 109 + 7 取余 的结果。如果最大积为 负数 ，则返回 -1 。</p>
<p>注意，取余是在得到最大积之后执行的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="1594_1.jpg" /></p>
<p>输入：grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]<br />
输出：-1<br />
解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 。</p>
<p><strong>示例 2：</strong></p>
<p><img src="1594_2.jpg" /></p>
<p>输入：grid = [[1,-2,1],[1,-2,1],[3,-4,1]]<br />
输出：8<br />
解释：最大非负积对应的路径如图所示 (1 * 1 * -2 * -4 * 1 = 8)</p>
<p><strong>示例 3：</strong></p>
<p><img src="1594_3.jpg" /></p>
<p>输入：grid = [[1,3],[0,-4]]<br />
输出：0<br />
解释：最大非负积对应的路径如图所示 (1 * 0 * -4 = 0)</p>
<p>非常直观的min,max双状态dp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProductPath</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># init</span></span><br><span class="line">        dp_max = [grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp_min = [grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp_max[j] = dp_max[j-<span class="number">1</span>] * grid[<span class="number">0</span>][j]</span><br><span class="line">            dp_min[j] = dp_min[j-<span class="number">1</span>] * grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="comment"># itter</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = dp_max[j]*grid[i][j], dp_min[j]*grid[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = <span class="built_in">max</span>(dp_max[j],dp_max[j-<span class="number">1</span>]) * grid[i][j], <span class="built_in">min</span>(dp_min[j],dp_min[j-<span class="number">1</span>]) * grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = dp_min[j]*grid[i][j], dp_max[j]*grid[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = <span class="built_in">min</span>(dp_min[j],dp_min[j-<span class="number">1</span>]) * grid[i][j], <span class="built_in">max</span>(dp_max[j],dp_max[j-<span class="number">1</span>]) * grid[i][j]</span><br><span class="line">        <span class="keyword">if</span> dp_max[-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dp_max[-<span class="number">1</span>] % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="最大得分的路径数目">1301. 最大得分的路径数目</h3>
<p>给你一个正方形字符数组 board ，你从数组最右下方的字符 'S' 出发。</p>
<p>你的目标是到达数组最左上角的字符 'E' ，数组剩余的部分为数字字符 1, 2, ..., 9 或者障碍 'X'。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>
<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>
<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。</p>
<p>如果没有任何路径可以到达终点，请返回 [0, 0] 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]</span><br><span class="line">    输出：[7,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：board = [&quot;E12&quot;,&quot;1X1&quot;,&quot;21S&quot;]</span><br><span class="line">    输出：[4,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：board = [&quot;E11&quot;,&quot;XXX&quot;,&quot;11S&quot;]</span><br><span class="line">    输出：[0,0]</span><br></pre></td></tr></table></figure>
<p>挺简单的, 应该不算hard. 比较烦的也就是从右下到左上, 以及全图都是字符串需要额外处理. 次数的话每次检测最大值的时候顺手算一下多少输入源可获得最大值, 然后频率加上去就行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathsWithMaxScore</span>(<span class="params">self, board: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        board[<span class="number">0</span>] = <span class="string">&#x27;0&#x27;</span>+board[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line">        board[-<span class="number">1</span>] = board[-<span class="number">1</span>][:-<span class="number">1</span>]+<span class="string">&#x27;0&#x27;</span></span><br><span class="line">        dp[-<span class="number">1</span>] = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            new_dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                    new_dp[j][<span class="number">0</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == n-<span class="number">1</span>:</span><br><span class="line">                        new_dp[j][<span class="number">0</span>] = dp[j][<span class="number">0</span>] + <span class="built_in">int</span>(board[i][j])</span><br><span class="line">                        new_dp[j][<span class="number">1</span>] = dp[j][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> i == m-<span class="number">1</span>:</span><br><span class="line">                            new_dp[j][<span class="number">0</span>] = new_dp[j+<span class="number">1</span>][<span class="number">0</span>] + <span class="built_in">int</span>(board[i][j])</span><br><span class="line">                            new_dp[j][<span class="number">1</span>] = new_dp[j+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            max_ = <span class="built_in">max</span>(dp[j][<span class="number">0</span>],new_dp[j+<span class="number">1</span>][<span class="number">0</span>],dp[j+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                            <span class="keyword">if</span> dp[j][<span class="number">0</span>] == max_:</span><br><span class="line">                                new_dp[j][<span class="number">1</span>] += dp[j][<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">if</span> dp[j+<span class="number">1</span>][<span class="number">0</span>] == max_:</span><br><span class="line">                                new_dp[j][<span class="number">1</span>] += dp[j+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">if</span> new_dp[j+<span class="number">1</span>][<span class="number">0</span>] == max_:</span><br><span class="line">                                new_dp[j][<span class="number">1</span>] += new_dp[j+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                            new_dp[j][<span class="number">0</span>] = max_ + <span class="built_in">int</span>(board[i][j])</span><br><span class="line">            dp = new_dp</span><br><span class="line">        res = dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> [res[<span class="number">0</span>]%mod,res[<span class="number">1</span>]%mod]</span><br></pre></td></tr></table></figure>
<h3 id="矩阵中和能被-k-整除的路径">2435. 矩阵中和能被 K 整除的路径</h3>
<p>给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k 。你从起点 (0, 0) 出发，每一步只能往 下 或者往 右 ，你想要到达终点 (m - 1, n - 1) 。</p>
<p>请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 109 + 7 取余 的结果。</p>
<p>示例 1：</p>
<p><img src="2435_1.png" /></p>
<p>输入：grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3<br />
输出：2<br />
解释：有两条路径满足路径上元素的和能被 k 整除。<br />
第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。<br />
第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。</p>
<p>示例 2：</p>
<p><img src="2435_2.png" /></p>
<p>输入：grid = [[0,0]], k = 5<br />
输出：1<br />
解释：红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。</p>
<p>示例 3：</p>
<p><img src="2435_3.png" /></p>
<p>输入：grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1<br />
输出：10<br />
解释：每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。</p>
<p>三层嵌套, dp里面每个元素是一个长度为k的列表, 每次读入数据的时候先合并染后shift一下.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfPaths</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="keyword">for</span> _j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_ += grid[<span class="number">0</span>][j]</span><br><span class="line">            dp[j][sum_%k] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            new_dp = [[<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="keyword">for</span> _j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                    up_l = dp[j][l]</span><br><span class="line">                    left_l = new_dp[j-<span class="number">1</span>][l] <span class="keyword">if</span> j != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    new_dp[j][(l+grid[i][j])%k] += up_l + left_l</span><br><span class="line">            dp = new_dp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>] % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="地下城游戏">174. 地下城游戏</h3>
<p>恶魔们抓住了公主并将她关在了地下城 dungeon 的 右下角 。地下城是由 m x n 个房间组成的二维网格。我们英勇的骑士最初被安置在 左上角 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快解救公主，骑士决定每次只 向右 或 向下 移动一步。</p>
<p>返回确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>注意：任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>
<p>示例 1：</p>
<p><img src="174_1.jpg" /></p>
<p>输入：dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]<br />
输出：7<br />
解释：如果骑士遵循最佳路径：右 -&gt; 右 -&gt; 下 -&gt; 下 ，则骑士的初始健康点数至少为 7 。</p>
<p>示例 2：</p>
<p>输入：dungeon = [[0]]<br />
输出：1</p>
<p>思路很不好想, 这题入口点在"从最后一格到第一格", dp记录从[m-1,n-1]到当前位置的最小值. 针对输入我们取最大值, 如果最大值大于0我们取0, 否则保持负数. 最后从dp[0]做返回.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculateMinimumHP</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[-<span class="number">1</span>] = <span class="built_in">min</span>(grid[-<span class="number">1</span>][-<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j + <span class="number">1</span>] + grid[-<span class="number">1</span>][j], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                right = dp[j + <span class="number">1</span>] <span class="keyword">if</span> j != n - <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(<span class="built_in">max</span>(right + grid[i][j], dp[j] + grid[i][j]), <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -dp[<span class="number">0</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵中的最长递增路径">329. 矩阵中的最长递增路径</h3>
<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p>示例 1：</p>
<p><img src="329_1.jpg" /></p>
<p>输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]<br />
输出：4<br />
解释：最长递增路径为 [1, 2, 6, 9]。</p>
<p>示例 2：</p>
<p><img src="329_2.jpg" /></p>
<p>输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]<br />
输出：4<br />
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</p>
<p>示例 3：</p>
<p>输入：matrix = [[1]]<br />
输出：1</p>
<p>老实说这题更像是dfs.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestIncreasingPath</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        directions = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">            max_ = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                new_x = x + dx</span><br><span class="line">                new_y = y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=new_x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=new_y&lt;n <span class="keyword">and</span> matrix[new_x][new_y] &gt; matrix[x][y]:</span><br><span class="line">                    max_ = <span class="built_in">max</span>(max_, dfs(new_x, new_y)+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> max_</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dfs(i,j))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="网格图中递增路径的数目">2328. 网格图中递增路径的数目</h3>
<p>给你一个 m x n 的整数网格图 grid ，你可以从一个格子移动到 4 个方向相邻的任意一个格子。</p>
<p>请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 10^9 + 7 取余 后返回。</p>
<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p>
<p>示例 1：</p>
<p><img src="2328_1.png" /></p>
<p>输入：grid = [[1,1],[3,4]]<br />
输出：8<br />
解释：严格递增路径包括：<br />
- 长度为 1 的路径：[1]，[1]，[3]，[4] 。<br />
- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。<br />
- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。<br />
路径数目为 4 + 3 + 1 = 8 。</p>
<p>示例 2：</p>
<p>输入：grid = [[1],[2]]<br />
输出：3<br />
解释：严格递增路径包括：<br />
- 长度为 1 的路径：[1]，[2] 。<br />
- 长度为 2 的路径：[1 -&gt; 2] 。<br />
路径数目为 2 + 1 = 3 。</p>
<p>dfs做法, 可以调cache装饰器, 但是占用内存会多一些, 自己手写一个dp表做查询更省内存.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPaths</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        directions = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp = [[-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[x][y] != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[x][y]</span><br><span class="line">            curr = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                new_x = x + dx</span><br><span class="line">                new_y = y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;= new_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; n <span class="keyword">and</span> grid[new_x][new_y] &gt; grid[x][y]:</span><br><span class="line">                    curr += dfs(new_x, new_y) % mod</span><br><span class="line">            dp[x][y] = curr % mod</span><br><span class="line">            <span class="keyword">return</span> curr % mod</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                ans += dfs(i,j) % mod</span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br></pre></td></tr></table></figure>
<p>也可以拓扑排序, 从数值最低的点开始处理.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPaths</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        directions = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        node = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                heapq.heappush(node, [grid[i][j], i, j])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _j <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            curr, x, y = heapq.heappop(node)</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                new_x = x + dx</span><br><span class="line">                new_y = y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= new_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; n <span class="keyword">and</span> grid[new_x][new_y] &lt; curr:</span><br><span class="line">                    res += dp[new_x][new_y]</span><br><span class="line">            res %= mod</span><br><span class="line">            dp[x][y] = res</span><br><span class="line">            ans += dp[x][y]</span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br></pre></td></tr></table></figure>
<h3 id="检查是否有合法括号字符串路径">2267. 检查是否有合法括号字符串路径</h3>
<p>一个括号字符串是一个 <strong>非空</strong> 且只包含 <code>'('</code> 和 <code>')'</code> 的字符串。如果下面 <strong>任意</strong> 条件为 <strong>真</strong> ，那么这个括号字符串就是 <strong>合法的</strong> 。</p>
<ul>
<li>字符串是 <code>()</code> 。</li>
<li>字符串可以表示为 <code>AB</code>（<code>A</code> 连接 <code>B</code>），<code>A</code> 和 <code>B</code> 都是合法括号序列。</li>
<li>字符串可以表示为 <code>(A)</code> ，其中 <code>A</code> 是合法括号序列。</li>
</ul>
<p>给你一个 <code>m x n</code> 的括号网格图矩阵 <code>grid</code> 。网格图中一个 <strong>合法括号路径</strong> 是满足以下所有条件的一条路径：</p>
<ul>
<li>路径开始于左上角格子 <code>(0, 0)</code> 。</li>
<li>路径结束于右下角格子 <code>(m - 1, n - 1)</code> 。</li>
<li>路径每次只会向 <strong>下</strong> 或者向 <strong>右</strong> 移动。</li>
<li>路径经过的格子组成的括号字符串是 <strong>合法</strong> 的。</li>
</ul>
<p>如果网格图中存在一条 <strong>合法括号路径</strong> ，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png" /></p>
<p><strong>输入：</strong>grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]<br />
<strong>输出：</strong>true<br />
<strong>解释：</strong>上图展示了两条路径，它们都是合法括号字符串路径。<br />
第一条路径得到的合法字符串是 "()(())" 。<br />
第二条路径得到的合法字符串是 "((()))" 。<br />
注意可能有其他的合法括号字符串路径。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png" /></p>
<p><strong>输入：</strong>grid = [[")",")"],["(","("]]<br />
<strong>输出：</strong>false<br />
<strong>解释：</strong>两条可行路径分别得到 "))(" 和 ")((" 。由于它们都不是合法括号字符串，我们返回 false 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>grid[i][j]</code> 要么是 <code>'('</code> ，要么是 <code>')'</code> 。</li>
</ul>
<p>dfs即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasValidPath</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;)&#x27;</span> <span class="keyword">or</span> grid[-<span class="number">1</span>][-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> (m+n-<span class="number">1</span>) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,l,r</span>):</span><br><span class="line">            <span class="keyword">if</span> x == m-<span class="number">1</span> <span class="keyword">and</span> y == n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> l == r + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; l <span class="keyword">or</span> l &gt; (m + n - <span class="number">1</span>) // <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            below = dfs(x+<span class="number">1</span>,y,l,r) <span class="keyword">if</span> x != m-<span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> below:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            right = dfs(x,y+<span class="number">1</span>,l,r) <span class="keyword">if</span> y != n-<span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="扣分后的最大得分">1937. 扣分后的最大得分</h3>
<p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p>
<p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p>
<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 &lt;= r &lt; m - 1</code>），选中坐标为 <code>(r, c1)</code> 和 <code>(r + 1, c2)</code> 的格子，你的总得分 <strong>减少</strong> <code>abs(c1 - c2)</code> 。</p>
<p>请你返回你能得到的 <strong>最大</strong> 得分。</p>
<p><code>abs(x)</code> 定义为：</p>
<ul>
<li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。<br />
</li>
<li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png" /></p>
<p><strong>输入：</strong>points = [[1,2,3],[1,5,1],[3,1,1]]<br />
<strong>输出：</strong>9<br />
<strong>解释：</strong><br />
蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。<br />
你的总得分增加 3 + 5 + 3 = 11 。<br />
但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。<br />
你的最终得分为 11 - 2 = 9 。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png" /></p>
<p><strong>输入：</strong>points = [[1,5],[2,3],[4,2]]<br />
<strong>输出：</strong>11<br />
<strong>解释：</strong><br />
蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。<br />
你的总得分增加 5 + 3 + 4 = 12 。<br />
但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。<br />
你的最终得分为 12 - 1 = 11 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == points.length</code></li>
<li><code>n == points[r].length</code></li>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li><code>0 &lt;= points[r][c] &lt;= 105</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-points-with-cost/description/">https://leetcode.cn/problems/maximum-number-of-points-with-cost/description/</a></p>
<p>涉及到绝对值拆分, 对于第i行k列和前一行的第j列, 我们有</p>
<p><span class="math display">\[
j &lt;  k: dp(k) = dp(j) - (k-j) + grid[i][k]  \\
j &gt;= k: dp(k) = dp(j) - (j-k) + grid[i][k]
\]</span></p>
<p>所以我们可以对某一行同时从左从右遍历.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPoints</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            new_dp = dp.copy()</span><br><span class="line">            left_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            right_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># left_max和right_max为上一行最优</span></span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max - <span class="number">1</span>, dp[j])</span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max - <span class="number">1</span>, dp[n-j-<span class="number">1</span>])</span><br><span class="line">                <span class="comment"># 上一行最大加当前格子</span></span><br><span class="line">                <span class="comment"># 由于同时从两侧, 所以new_dp[j]会被算两次, 我们取最大值.</span></span><br><span class="line">                new_dp[j] = <span class="built_in">max</span>(left_max + grid[i][j], new_dp[j])</span><br><span class="line">                new_dp[n-j-<span class="number">1</span>] = <span class="built_in">max</span>(right_max + grid[i][n-j-<span class="number">1</span>], new_dp[n-j-<span class="number">1</span>])</span><br><span class="line">            dp = new_dp</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="摘樱桃-ii">1463. 摘樱桃 II</h3>
<p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<ul>
<li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li>
<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>
<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>
<li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li>
<li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png" /></strong></p>
<p><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]<br />
<strong>输出：</strong>24<br />
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。<br />
机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。<br />
机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。<br />
樱桃总数为： 12 + 12 = 24 。</p>
<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png" /></strong></p>
<p><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]<br />
<strong>输出：</strong>28<br />
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。<br />
机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。<br />
机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。<br />
樱桃总数为： 17 + 11 = 28 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]<br />
<strong>输出：</strong>22</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>grid = [[1,1],[1,1]]<br />
<strong>输出：</strong>4</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code> </li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup-ii/description/">https://leetcode.cn/problems/cherry-pickup-ii/description/</a></p>
<p>摘樱桃1和2都挺难的, 主要是思路很难想到. 摘樱桃1主要得想到用三维dp(压缩后二维), dp[j][k]表示左机器人在j列,右机器人在k列的时候的最大值. 其他就是一个遍历, 需要注意剪枝, 想通了之后代码思路还是比较直观的.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cherryPickup</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][-<span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][-<span class="number">1</span>]</span><br><span class="line">        new_dp = copy.deepcopy(dp)</span><br><span class="line">        shift = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(i+<span class="number">1</span>,n-<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(j+<span class="number">1</span>,n-i-<span class="number">1</span>), n):</span><br><span class="line">                    max_ = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                    <span class="keyword">for</span> dj <span class="keyword">in</span> shift:</span><br><span class="line">                        <span class="keyword">for</span> dk <span class="keyword">in</span> shift:</span><br><span class="line">                            new_j = j + dj</span><br><span class="line">                            new_k = k + dk</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= new_j &lt; new_k &lt;= n-<span class="number">1</span>: </span><br><span class="line">                                max_ = <span class="built_in">max</span>(max_, dp[new_j][new_k])</span><br><span class="line">                    new_dp[j][k] = max_ + grid[i][j] + grid[i][k]</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, new_dp[j][k])</span><br><span class="line">            dp, new_dp = new_dp, dp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="摘樱桃">741. 摘樱桃</h3>
<p>给你一个 <code>n x n</code> 的网格 <code>grid</code> ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：</p>
<ul>
<li><code>0</code> 表示这个格子是空的，所以你可以穿过它。</li>
<li><code>1</code> 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>
<li><code>-1</code> 表示这个格子里有荆棘，挡着你的路。</li>
</ul>
<p>请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：</p>
<ul>
<li>从位置 <code>(0, 0)</code> 出发，最后到达 <code>(n - 1, n - 1)</code> ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 <code>0</code> 或者 <code>1</code> 的格子）；</li>
<li>当到达 <code>(n - 1, n - 1)</code> 后，你要继续走，直到返回到 <code>(0, 0)</code> ，只能向上或向左走，并且只能穿越有效的格子；</li>
<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 <code>0</code> ）；</li>
<li>如果在 <code>(0, 0)</code> 和 <code>(n - 1, n - 1)</code> 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg" /></p>
<p><strong>输入：</strong>grid = [[0,1,-1],[1,0,-1],[1,1,1]]<br />
<strong>输出：</strong>5<br />
<strong>解释：</strong>玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。<br />
在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。<br />
然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。<br />
总共捡到 5 个樱桃，这是最大可能值。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>grid = [[1,1,-1],[1,-1,1],[-1,1,1]]<br />
<strong>输出：</strong>0</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>grid[i][j]</code> 为 <code>-1</code>、<code>0</code> 或 <code>1</code></li>
<li><code>grid[0][0] != -1</code></li>
<li><code>grid[n - 1][n - 1] != -1</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/description/">https://leetcode.cn/problems/cherry-pickup/description/</a></p>
<p>首先想到可以问题转化, 从第一格到最后一格再回去, 这个问题可以转化为两个机器人同时从(0,0)出发到(m-1,n-1). 然后可以用二维dp解决.</p>
<p>但是即使如此还是有问题, 不同于摘樱桃2, 我们这里的i并不是相同的, 所以如果想要记录两个点的位置我们需要4个索引, 且不可压缩, 这种开销就有点不可接受了.</p>
<p>解决方法是我们用step数量作第一个纬度, 然后用两个机器人的列数作第二三维度. 这样机器人1的坐标就是[t-j, j], 机器人2就是[t-k,k], 这样我们就和上一题一样, 开个二维数组遍历即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cherryPickup</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n*<span class="number">2</span>-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(t,n-<span class="number">1</span>), <span class="built_in">max</span>(t-n, -<span class="number">1</span>), -<span class="number">1</span>):</span><br><span class="line">                row_j = t-j</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(t,n-<span class="number">1</span>), j-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    row_k = t-k</span><br><span class="line">                    <span class="keyword">if</span> grid[row_j][j] == -<span class="number">1</span> <span class="keyword">or</span> grid[row_k][k] == -<span class="number">1</span>:</span><br><span class="line">                        dp[j+<span class="number">1</span>][k+<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[j+<span class="number">1</span>][k+<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][k], dp[j+<span class="number">1</span>][k], dp[j][k+<span class="number">1</span>], dp[j+<span class="number">1</span>][k+<span class="number">1</span>]) + grid[row_j][j] + (grid[row_k][k] <span class="keyword">if</span> j!= k <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n][n], <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%89%8D%E7%8A%B6%E6%80%81%E5%8A%A0%E5%88%B0%E5%90%8E%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">爬楼梯(前状态加到后状态)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-2466.-%E7%BB%9F%E8%AE%A1%E6%9E%84%E9%80%A0%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础: 2466. 统计构造好字符串的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-2266.-%E7%BB%9F%E8%AE%A1%E6%89%93%E5%AD%97%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">进阶: 2266. 统计打字方案数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.</span> <span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础: 198. 打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-3186.-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">进阶: 3186. 施咒的最大总伤害</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">基础: 53. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B61-918.-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">进阶1: 918. 环形子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B62-1191.-k-%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">进阶2: 1191. K 次串联后最大子数组之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%89%A9%E5%B1%95-152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">思路扩展: 152. 乘积最大子数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BCdp"><span class="toc-number">1.4.</span> <span class="toc-text">网格dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%82%B9%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础点的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">2684. 矩阵中移动的最大次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.4.3.</span> <span class="toc-text">2304. 网格中的最小路径代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%9E%E8%B4%9F%E7%A7%AF"><span class="toc-number">1.4.5.</span> <span class="toc-text">1594. 矩阵的最大非负积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.6.</span> <span class="toc-text">1301. 最大得分的路径数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%AB-k-%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.7.</span> <span class="toc-text">2435. 矩阵中和能被 K 整除的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="toc-number">1.4.8.</span> <span class="toc-text">174. 地下城游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.9.</span> <span class="toc-text">329. 矩阵中的最长递增路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.10.</span> <span class="toc-text">2328. 网格图中递增路径的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.11.</span> <span class="toc-text">2267. 检查是否有合法括号字符串路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">1.4.12.</span> <span class="toc-text">1937. 扣分后的最大得分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83-ii"><span class="toc-number">1.4.13.</span> <span class="toc-text">1463. 摘樱桃 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83"><span class="toc-number">1.4.14.</span> <span class="toc-text">741. 摘樱桃</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=DSA-动态规划"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=DSA-动态规划"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DSA-动态规划&body=Check out this article: http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=DSA-动态规划&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=DSA-动态规划"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    blacsheep
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
