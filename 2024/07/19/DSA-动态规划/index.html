<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="dp这一块我一直觉得是算法里面比较难的一块, 思路千奇百怪. 虽然核心思路都是记录状态, 从前状态推后状态从而得出结果, 然而实际题目里面很多时候会有各种各样的问题, 比如递推关系抽象不出来, 又或者情况复杂导致判断多, 边界处理不当等等. 这几天稍微刷了刷dp, 简单记录. 后续也会坚持刷刷dp, 对思维还是很有帮助的. 题目分类来自: 灵茶山艾府-分享丨【题单】动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划">
<meta property="og:type" content="article">
<meta property="og:title" content="DSA-动态规划">
<meta property="og:url" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="blacsheep&#39;s blog">
<meta property="og:description" content="dp这一块我一直觉得是算法里面比较难的一块, 思路千奇百怪. 虽然核心思路都是记录状态, 从前状态推后状态从而得出结果, 然而实际题目里面很多时候会有各种各样的问题, 比如递推关系抽象不出来, 又或者情况复杂导致判断多, 边界处理不当等等. 这几天稍微刷了刷dp, 简单记录. 后续也会坚持刷刷dp, 对思维还是很有帮助的. 题目分类来自: 灵茶山艾府-分享丨【题单】动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9key.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1594_1.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1594_2.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1594_3.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2435_1.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2435_2.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2435_3.png">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/174_1.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/329_1.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/329_2.jpg">
<meta property="og:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2328_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1628843202-cdFPSt-c24754f1a5ff56989340ba5004dc5eda.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/1628841618-bFKsnt-c60e38199a225ad62f13b954872edf9b.gif">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/08/03/matrix1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/11/09/e1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg">
<meta property="article:published_time" content="2024-07-19T07:53:51.000Z">
<meta property="article:modified_time" content="2024-07-26T13:07:48.979Z">
<meta property="article:author" content="blacsheep">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9key.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>DSA-动态规划</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/07/21/DSA-misc/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/07/12/DSA%E6%B5%81%E7%A8%8B%E4%BC%98%E5%8C%96/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=DSA-动态规划"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=DSA-动态规划"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DSA-动态规划&body=Check out this article: http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=DSA-动态规划&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=DSA-动态规划"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%89%8D%E7%8A%B6%E6%80%81%E5%8A%A0%E5%88%B0%E5%90%8E%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">爬楼梯(前状态加到后状态)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-2466.-%E7%BB%9F%E8%AE%A1%E6%9E%84%E9%80%A0%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础: 2466. 统计构造好字符串的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-2266.-%E7%BB%9F%E8%AE%A1%E6%89%93%E5%AD%97%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">进阶: 2266. 统计打字方案数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.</span> <span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础: 198. 打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-3186.-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">进阶: 3186. 施咒的最大总伤害</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">基础: 53. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B61-918.-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">进阶1: 918. 环形子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B62-1191.-k-%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">进阶2: 1191. K 次串联后最大子数组之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.3.4.</span> <span class="toc-text">1186. 删除一次得到子数组最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%89%A9%E5%B1%95-152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">思路扩展: 152. 乘积最大子数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BCdp"><span class="toc-number">1.4.</span> <span class="toc-text">网格dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%82%B9%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础点的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">2684. 矩阵中移动的最大次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.4.3.</span> <span class="toc-text">2304. 网格中的最小路径代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%9E%E8%B4%9F%E7%A7%AF"><span class="toc-number">1.4.5.</span> <span class="toc-text">1594. 矩阵的最大非负积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.6.</span> <span class="toc-text">1301. 最大得分的路径数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%AB-k-%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.7.</span> <span class="toc-text">2435. 矩阵中和能被 K 整除的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="toc-number">1.4.8.</span> <span class="toc-text">174. 地下城游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.9.</span> <span class="toc-text">329. 矩阵中的最长递增路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.10.</span> <span class="toc-text">2328. 网格图中递增路径的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.11.</span> <span class="toc-text">2267. 检查是否有合法括号字符串路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">1.4.12.</span> <span class="toc-text">1937. 扣分后的最大得分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83-ii"><span class="toc-number">1.4.13.</span> <span class="toc-text">1463. 摘樱桃 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83"><span class="toc-number">1.4.14.</span> <span class="toc-text">741. 摘樱桃</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">背包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85-1"><span class="toc-number">2.1.</span> <span class="toc-text">0-1背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">2915. 和为目标值的最长子序列的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">494. 目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%88%90%E5%B9%82%E7%9A%84%E5%92%8C%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">2787. 将一个数字表示成幂的和的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-i"><span class="toc-number">2.1.5.</span> <span class="toc-text">3180. 执行操作可获得的最大总奖励 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">2.1.6.</span> <span class="toc-text">474. 一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii"><span class="toc-number">2.1.7.</span> <span class="toc-text">1049. 最后一块石头的重量 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC"><span class="toc-number">2.1.8.</span> <span class="toc-text">1774. 最接近目标价格的甜点成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%88%E5%88%A9%E8%AE%A1%E5%88%92"><span class="toc-number">2.1.9.</span> <span class="toc-text">879. 盈利计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E8%83%BD%E9%87%8F%E5%92%8C"><span class="toc-number">2.1.10.</span> <span class="toc-text">3082. 求出所有子序列的能量和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E7%9A%84%E5%B9%BF%E5%91%8A%E7%89%8C"><span class="toc-number">2.1.11.</span> <span class="toc-text">956. 最高的广告牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%88%86%E5%8C%BA%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.1.12.</span> <span class="toc-text">2518. 好分区的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%A2%99%E5%A3%81%E5%88%B7%E6%B2%B9%E6%BC%86"><span class="toc-number">2.1.13.</span> <span class="toc-text">2742. 给墙壁刷油漆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lcp-47.-%E5%85%A5%E5%9C%BA%E5%AE%89%E6%A3%80"><span class="toc-number">2.1.14.</span> <span class="toc-text">LCP 47. 入场安检</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">2.2.</span> <span class="toc-text">完全背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii"><span class="toc-number">2.2.2.</span> <span class="toc-text">518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">279. 完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-number">2.2.4.</span> <span class="toc-text">1449. 数位成本和为目标值的最大数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.</span> <span class="toc-text">多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%88%86%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2585. 获得分数的方法数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">2902. 和带限制的子多重集合的数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-number">2.4.</span> <span class="toc-text">分组背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%92%8C%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">1155. 掷骰子等于目标和的方法数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%8E%E6%89%80%E9%80%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%B7%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">1981. 最小化目标值与所选元素的差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%A0%88%E4%B8%AD%E5%8F%96%E5%87%BA-k-%E4%B8%AA%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E5%80%BC%E5%92%8C"><span class="toc-number">2.4.3.</span> <span class="toc-text">2218. 从栈中取出 K 个硬币的最大面值和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BA%BF%E6%80%A7dp"><span class="toc-number">3.</span> <span class="toc-text">经典线性dp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lcs%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">LCS(最长公共子序列)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">1143. 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">583. 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C"><span class="toc-number">3.1.3.</span> <span class="toc-text">712. 两个字符串的最小ASCII删除和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">3.1.4.</span> <span class="toc-text">72. 编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.1.5.</span> <span class="toc-text">97. 交错字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.6.</span> <span class="toc-text">115. 不同的子序列</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        DSA-动态规划
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">blacsheep</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-07-19T07:53:51.000Z" class="dt-published" itemprop="datePublished">2024-07-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>dp这一块我一直觉得是算法里面比较难的一块, 思路千奇百怪. 虽然核心思路都是记录状态, 从前状态推后状态从而得出结果, 然而实际题目里面很多时候会有各种各样的问题, 比如递推关系抽象不出来, 又或者情况复杂导致判断多, 边界处理不当等等.</p>
<p>这几天稍微刷了刷dp, 简单记录. 后续也会坚持刷刷dp, 对思维还是很有帮助的.</p>
<p>题目分类来自: <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tXLS3i/">灵茶山艾府-分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化）</a></p>
<h1 id="入门">入门</h1>
<h2 id="爬楼梯前状态加到后状态">爬楼梯(前状态加到后状态)</h2>
<h3 id="基础-2466.-统计构造好字符串的方案数">基础: 2466. 统计构造好字符串的方案数</h3>
<p>给你整数 zero ，one ，low 和 high ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ul>
<li>将 '0' 在字符串末尾添加 <code>zero</code> 次。<br />
</li>
<li>将 '1' 在字符串末尾添加 <code>one</code> 次。</li>
</ul>
<p>以上操作可以执行任意次。</p>
<p>如果通过以上过程得到一个 长度 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <code>好</code> 字符串。</p>
<p>请你返回满足以上要求的 不同 好字符串数目。由于答案可能很大，请将结果对 10^9 + 7 取余 后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">    输出：8</span><br><span class="line">    解释：</span><br><span class="line">    一个可能的好字符串是 &quot;011&quot; 。</span><br><span class="line">    可以这样构造得到：&quot;&quot; -&gt; &quot;0&quot; -&gt; &quot;01&quot; -&gt; &quot;011&quot; 。</span><br><span class="line">    从 &quot;000&quot; 到 &quot;111&quot; 之间所有的二进制字符串都是好字符串。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：low = 2, high = 3, zero = 1, one = 2</span><br><span class="line">    输出：5</span><br><span class="line">    解释：好字符串为 &quot;00&quot; ，&quot;11&quot; ，&quot;000&quot; ，&quot;110&quot; 和 &quot;011&quot; 。</span><br></pre></td></tr></table></figure>
<p>爬楼梯问题, 在上一次的基础上爬zero或者one个台阶.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countGoodStrings</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, zero: <span class="built_in">int</span>, one: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        lst = [zero, one]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> lst:</span><br><span class="line">                <span class="keyword">if</span> i&gt;=num:</span><br><span class="line">                    dp[i] += dp[i-num] % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">if</span> low&lt;=i&lt;=high:</span><br><span class="line">                ans += dp[i] % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> ans % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="进阶-2266.-统计打字方案数">进阶: 2266. 统计打字方案数</h3>
<p>Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。</p>
<p><img src="9key.png" /></p>
<p>为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。</p>
<p>比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母 'k' 。</p>
<p>注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice<strong>不</strong>使用它们。</p>
<p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。</p>
<p>比方说，Alice 发出的信息为 "bob" ，Bob 将收到字符串 "2266622" 。</p>
<p>给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。</p>
<p>由于答案可能很大，将它对 10^9 + 7 取余 后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：pressedKeys = &quot;22233&quot;</span><br><span class="line">    输出：8</span><br><span class="line">    解释：</span><br><span class="line">    Alice 可能发出的文字信息包括：</span><br><span class="line">    &quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot; 和 &quot;ce&quot; 。</span><br><span class="line">    由于总共有 8 种可能的信息，所以我们返回 8 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：pressedKeys = &quot;222222222222222222222222222222222222&quot;</span><br><span class="line">    输出：82876089</span><br><span class="line">    解释：</span><br><span class="line">    总共有 2082876103 种 Alice 可能发出的文字信息。</span><br><span class="line">    由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。</span><br></pre></td></tr></table></figure>
<p>9键输入转可能输出. 反向爬楼梯, 读到连续k个输入的时候每次下个输入都可以建立在合法的k-1,k-2,k-3上(如果为79还有k-4).</p>
<p>针对79和其他输入, 我们分three_stack和four_stack, 检测连续输入, 做叠加即可获取长度为n的连续同字符输入. 然后不同group做乘积即可.</p>
<p>当然, 由于同字符连续输入的输出可能数量总相同, 所以可以预处理先算出所有可能数量, 然后直接统计连续字符数去查询结果就行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countTexts</span>(<span class="params">self, pressedKeys: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        three_stack = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        four_stack = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(pressedKeys)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">while</span> i != n-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> pressedKeys[i] != pressedKeys[i+<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pressedKeys[i] <span class="keyword">in</span> <span class="string">&#x27;79&#x27;</span>:</span><br><span class="line">                stack = four_stack.copy()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack = three_stack.copy()</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> pressedKeys[i] == pressedKeys[i+<span class="number">1</span>]:</span><br><span class="line">                sum_ = <span class="built_in">sum</span>(stack) % mod</span><br><span class="line">                stack.pop(<span class="number">0</span>)</span><br><span class="line">                stack.append(sum_)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            start *= stack[-<span class="number">1</span>]</span><br><span class="line">            start %= mod</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<h2 id="打家劫舍">打家劫舍</h2>
<h3 id="基础-198.-打家劫舍">基础: 198. 打家劫舍</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：[1,2,3,1]</span><br><span class="line">    输出：4</span><br><span class="line">    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">        偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：[2,7,9,3,1]</span><br><span class="line">    输出：12</span><br><span class="line">    解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">        偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<p>每次偷窃与否基于前两个状态. 即 <code>f(n+1) = max(f(n),f(n-1)+value[n+1])</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="built_in">max</span>(nums[i-<span class="number">1</span>], nums[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> nums[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="进阶-3186.-施咒的最大总伤害">进阶: 3186. 施咒的最大总伤害</h3>
<p>一个魔法师有许多不同的咒语。</p>
<p>给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。</p>
<p>已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。</p>
<p>每个咒语最多只能被使用 一次 。</p>
<p>请你返回这个魔法师可以达到的伤害值之和的 最大值 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：power = [1,1,3,4]</span><br><span class="line">    输出：6</span><br><span class="line">    解释：</span><br><span class="line">    可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：power = [7,1,6,6]</span><br><span class="line">    输出：13</span><br><span class="line">    解释：</span><br><span class="line">    可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。</span><br></pre></td></tr></table></figure>
<p>首先最先看到是长度为3的打家劫舍, 初始思路可以直接找到最小值和最大值, 然后遍历一遍过去, 当打家劫舍来处理即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTotalDamage</span>(<span class="params">self, power: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_ = <span class="built_in">min</span>(power)</span><br><span class="line">        max_ = <span class="built_in">max</span>(power)</span><br><span class="line">        ctr = Counter(power)</span><br><span class="line"></span><br><span class="line">        score = [ctr[min_]*min_, ctr[min_+<span class="number">1</span>]*(min_+<span class="number">1</span>), ctr[min_+<span class="number">2</span>]*(min_+<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">if</span> max_-min_+<span class="number">1</span> &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(score)</span><br><span class="line">        dp = [score[<span class="number">0</span>], <span class="built_in">max</span>(score[<span class="number">0</span>],score[<span class="number">1</span>]), <span class="built_in">max</span>(score[:<span class="number">3</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, max_-min_+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">1</span>], dp[<span class="number">2</span>], <span class="built_in">max</span>(dp[<span class="number">0</span>]+ctr[min_+i]*(min_+i), dp[<span class="number">1</span>], dp[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>非常直观, 但是很可惜这么写会直接TLE. 因为从min到max这中间计算了太多无用状态, 优化解法为调用counter, 排序key, 然后依序读取key来处理(流程优化, 其实也就是将中间数值为0的部分做直接传递而非逐步计算).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTotalDamage</span>(<span class="params">self, power: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ctr = Counter(power)</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        dp = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(ctr):</span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                prev = k</span><br><span class="line">                dp[-<span class="number">1</span>] = k*ctr[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> k == prev + <span class="number">1</span>:</span><br><span class="line">                    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">1</span>], dp[<span class="number">2</span>], <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">2</span>], dp[<span class="number">0</span>] + k*ctr[k])</span><br><span class="line">                <span class="keyword">elif</span> k == prev + <span class="number">2</span>:</span><br><span class="line">                    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">2</span>], dp[<span class="number">2</span>], <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>]+k*ctr[k])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = dp[<span class="number">2</span>], dp[<span class="number">2</span>], dp[<span class="number">2</span>] + k*ctr[k]</span><br><span class="line">                prev = k</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="最大子数组和">最大子数组和</h2>
<p>核心部分kadane算法, 即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curr = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">    curr = <span class="built_in">max</span>(curr+i,i)</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, curr)</span><br></pre></td></tr></table></figure>
<p>其中curr表示到i这个元素的时候可能构成的最大值, (curr+i)表示包含i,且curr表示上一个此状态的迭代解, i表示不包含前状态的解.</p>
<h3 id="基础-53.-最大子数组和">基础: 53. 最大子数组和</h3>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组是数组中的一个连续部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">    输出：6</span><br><span class="line">    解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：nums = [1]</span><br><span class="line">    输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：nums = [5,4,-1,7,8]</span><br><span class="line">    输出：23</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            curr = <span class="built_in">max</span>(curr+i, i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="进阶1-918.-环形子数组的最大和">进阶1: 918. 环形子数组的最大和</h3>
<p>给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。</p>
<p>环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。</p>
<p>子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % n == k2 % n 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：nums = [1,-2,3,-2]</span><br><span class="line">    输出：3</span><br><span class="line">    解释：从子数组 [3] 得到最大和 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：nums = [5,-3,5]</span><br><span class="line">    输出：10</span><br><span class="line">    解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：nums = [3,-2,2,-3]</span><br><span class="line">    输出：3</span><br><span class="line">    解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</span><br></pre></td></tr></table></figure>
<p>掌握思路就很简单, 两种可能:</p>
<ol type="1">
<li>找中间部分最大(kadane)<br />
</li>
<li>最大部分为尾串+首串; 又由于数组大小总数一定, 即找到中间部分最小的字串, 依旧是kadane.</li>
</ol>
<h3 id="进阶2-1191.-k-次串联后最大子数组之和">进阶2: 1191. K 次串联后最大子数组之和</h3>
<p>给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。</p>
<p>例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。</p>
<p>返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。</p>
<p>由于 结果可能会很大，需要返回的 10^9 + 7 的 模 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：arr = [1,2], k = 3</span><br><span class="line">    输出：9</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：arr = [1,-2,1], k = 5</span><br><span class="line">    输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：arr = [-1,-2], k = 7</span><br><span class="line">    输出：0</span><br></pre></td></tr></table></figure>
<p>情况拆分, <code>k == 1</code>直接kadane即可; 一旦k大于1, 那么如果arr总和大于0, 那么我们一定会尽可能多读, 相当于kadane(arr+arr)+(k-2) * sum, 反之如果arr总和小于0, 那么我们直接对两个arr做kadane即可, 相当于kadane(arr+arr).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kConcatenationMaxSum</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">1</span>:</span><br><span class="line">            arr = arr + arr</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            curr = <span class="built_in">max</span>(curr, <span class="number">0</span>) + i</span><br><span class="line">            ans = <span class="built_in">max</span>(curr, ans)</span><br><span class="line">        <span class="keyword">return</span> (ans + (k&gt;<span class="number">1</span> <span class="keyword">and</span> sum_ &gt; <span class="number">0</span>) * (k-<span class="number">2</span>) * sum_) % mod</span><br></pre></td></tr></table></figure>
<h3 id="删除一次得到子数组最大和">1186. 删除一次得到子数组最大和</h3>
<p>给你一个整数数组，返回它的某个 <strong>非空</strong> 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p>
<p>注意，删除一个元素后，子数组 <strong>不能为空</strong>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>arr = [1,-2,0,3]<br />
<strong>输出：</strong>4<br />
<strong>解释：</strong>我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>arr = [1,-2,-2,3]<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>我们直接选出 [3]，这就是最大和。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>arr = [-1,-1,-1,-1]<br />
<strong>输出：</strong>-1<br />
<strong>解释：</strong>最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。<br />
我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 105</code></li>
<li><code>-104 &lt;= arr[i] &lt;= 104</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/description/?envType=daily-question&amp;envId=2024-07-21">https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/description/?envType=daily-question&amp;envId=2024-07-21</a></p>
<p>很有意思的题, 首先kadane算法算出来的是<strong>不可删除元素的</strong>,<strong>一直到元素i的</strong>解.</p>
<p>不删元素的迭代式记为dp_0, 如果删除一个元素, 我们把迭代式记为dp_1; 那么我们可能删除最后一个元素, 那么从前一个元素开始就不可以删除其他元素, 答案为dp_0; 又或者保留最后一个元素, 允许dp_1删除前面的元素, 那么答案为dp_1+i.</p>
<p>需要先计算dp_1, 如果先算dp_0那我们就相当于在用第二轮的dp_0算第一轮的dp_1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSum</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp_0 = dp_1 = ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            dp_1 = <span class="built_in">max</span>(dp_1 + i, dp_0)</span><br><span class="line">            dp_0 = <span class="built_in">max</span>(dp_0 + i, i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp_1, dp_0)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="思路扩展-152.-乘积最大子数组">思路扩展: 152. 乘积最大子数组</h3>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">    输入: nums = [2,3,-2,4]</span><br><span class="line">    输出: 6</span><br><span class="line">    解释: 子数组 [2,3] 有最大乘积 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">    输入: nums = [-2,0,-1]</span><br><span class="line">    输出: 0</span><br><span class="line">    解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>
<p>掌握思路就简单, 读入小于0的时候用最小值来获取最大值, 读入大于0用最大值获取最大值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curr_min = <span class="number">1</span></span><br><span class="line">        curr_max = <span class="number">1</span></span><br><span class="line">        ans_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                curr_min, curr_max = <span class="built_in">min</span>(curr_min * i, i), <span class="built_in">max</span>(curr_max * i, i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr_min, curr_max = <span class="built_in">min</span>(curr_max * i, i), <span class="built_in">max</span>(curr_min * i, i)</span><br><span class="line">            ans_max = <span class="built_in">max</span>(curr_max, ans_max)</span><br><span class="line">        <span class="keyword">return</span> ans_max</span><br></pre></td></tr></table></figure>
<h2 id="网格dp">网格dp</h2>
<p>主要是网格移动相关.</p>
<h3 id="基础点的">基础点的</h3>
<h3 id="矩阵中移动的最大次数">2684. 矩阵中移动的最大次数</h3>
<p>给你一个下标从 0 开始、大小为 m x n 的矩阵 grid ，矩阵由若干 正 整数组成。</p>
<p>你可以从矩阵第一列中的 任一 单元格出发，按以下方式遍历 grid ：</p>
<p>从单元格 (row, col) 可以移动到 (row - 1, col + 1)、(row, col + 1) 和 (row + 1, col + 1) 三个单元格中任一满足值 严格 大于当前单元格的单元格。</p>
<p>返回你在矩阵中能够 移动 的 最大 次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]</span><br><span class="line">    输出：3</span><br><span class="line">    解释：可以从单元格 (0, 0) 开始并且按下面的路径移动：</span><br><span class="line">    - (0, 0) -&gt; (0, 1).</span><br><span class="line">    - (0, 1) -&gt; (1, 2).</span><br><span class="line">    - (1, 2) -&gt; (2, 3).</span><br><span class="line">    可以证明这是能够移动的最大次数。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：grid = [[3,2,4],[2,1,9],[1,1,7]]</span><br><span class="line">    输出：0</span><br><span class="line">    解释：从第一列的任一单元格开始都无法移动。</span><br></pre></td></tr></table></figure>
<p>老实说我觉得这更像一个遍历的题而不是dp的题. 当dp的话就检测每一列的可以到达点, 然后下一轮继续. 我当时写的一个O(m*n)时间带剪枝+O(1)空间的dp.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxMoves</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = -grid[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            found = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="comment"># j,i</span></span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> -<span class="number">1</span> &lt; grid[j][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j+<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span>:</span><br><span class="line">                        grid[j][i] = - grid[j][i]</span><br><span class="line">                        found = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j == m-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> -<span class="number">1</span> &lt; grid[j][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j-<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span>:</span><br><span class="line">                        grid[j][i] = - grid[j][i]</span><br><span class="line">                        found = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> -<span class="number">1</span> &lt; grid[j][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j+<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span> &lt; grid[j-<span class="number">1</span>][i-<span class="number">1</span>] / grid[j][i] &lt; <span class="number">0</span>:</span><br><span class="line">                        grid[j][i] = - grid[j][i]</span><br><span class="line">                        found = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> found == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="网格中的最小路径代价">2304. 网格中的最小路径代价</h3>
<p>给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x &lt; m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。</p>
<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。</p>
<p>grid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</span><br><span class="line">    输出：17</span><br><span class="line">    解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。</span><br><span class="line">    - 路径途经单元格值之和 5 + 0 + 1 = 6 。</span><br><span class="line">    - 从 5 移动到 0 的代价为 3 。</span><br><span class="line">    - 从 0 移动到 1 的代价为 8 。</span><br><span class="line">    路径总代价为 6 + 3 + 8 = 17 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]</span><br><span class="line">    输出：6</span><br><span class="line">    解释：</span><br><span class="line">    最小代价的路径是 2 -&gt; 3 。 </span><br><span class="line">    - 路径途经单元格值之和 2 + 3 = 5 。 </span><br><span class="line">    - 从 2 移动到 3 的代价为 1 。 </span><br><span class="line">    路径总代价为 5 + 1 = 6 。</span><br></pre></td></tr></table></figure>
<p>描述复杂得要死, 实际就是个暴力, O(m*n^2).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathCost</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], moveCost: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [grid[<span class="number">0</span>][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp = [grid[i][k] + <span class="built_in">min</span>([dp[j] + moveCost[grid[i-<span class="number">1</span>][j]][k] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="进阶">进阶</h3>
<p>整体来说还是有一些难度的, 前面可能一眼看穿秒秒秒, 后面慢慢难度就上来了.</p>
<h3 id="矩阵的最大非负积">1594. 矩阵的最大非负积</h3>
<p>给你一个大小为 m x n 的矩阵 grid 。最初，你位于左上角 (0, 0) ，每一步，你可以在矩阵中 向右 或 向下 移动。</p>
<p>在从左上角 (0, 0) 开始到右下角 (m - 1, n - 1) 结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>
<p>返回 最大非负积 对 109 + 7 取余 的结果。如果最大积为 负数 ，则返回 -1 。</p>
<p>注意，取余是在得到最大积之后执行的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="1594_1.jpg" /></p>
<p>输入：grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]<br />
输出：-1<br />
解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 。</p>
<p><strong>示例 2：</strong></p>
<p><img src="1594_2.jpg" /></p>
<p>输入：grid = [[1,-2,1],[1,-2,1],[3,-4,1]]<br />
输出：8<br />
解释：最大非负积对应的路径如图所示 (1 * 1 * -2 * -4 * 1 = 8)</p>
<p><strong>示例 3：</strong></p>
<p><img src="1594_3.jpg" /></p>
<p>输入：grid = [[1,3],[0,-4]]<br />
输出：0<br />
解释：最大非负积对应的路径如图所示 (1 * 0 * -4 = 0)</p>
<p>非常直观的min,max双状态dp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProductPath</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># init</span></span><br><span class="line">        dp_max = [grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp_min = [grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp_max[j] = dp_max[j-<span class="number">1</span>] * grid[<span class="number">0</span>][j]</span><br><span class="line">            dp_min[j] = dp_min[j-<span class="number">1</span>] * grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="comment"># itter</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = dp_max[j]*grid[i][j], dp_min[j]*grid[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = <span class="built_in">max</span>(dp_max[j],dp_max[j-<span class="number">1</span>]) * grid[i][j], <span class="built_in">min</span>(dp_min[j],dp_min[j-<span class="number">1</span>]) * grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = dp_min[j]*grid[i][j], dp_max[j]*grid[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp_max[j], dp_min[j] = <span class="built_in">min</span>(dp_min[j],dp_min[j-<span class="number">1</span>]) * grid[i][j], <span class="built_in">max</span>(dp_max[j],dp_max[j-<span class="number">1</span>]) * grid[i][j]</span><br><span class="line">        <span class="keyword">if</span> dp_max[-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dp_max[-<span class="number">1</span>] % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="最大得分的路径数目">1301. 最大得分的路径数目</h3>
<p>给你一个正方形字符数组 board ，你从数组最右下方的字符 'S' 出发。</p>
<p>你的目标是到达数组最左上角的字符 'E' ，数组剩余的部分为数字字符 1, 2, ..., 9 或者障碍 'X'。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>
<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>
<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。</p>
<p>如果没有任何路径可以到达终点，请返回 [0, 0] 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">    输入：board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]</span><br><span class="line">    输出：[7,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">    输入：board = [&quot;E12&quot;,&quot;1X1&quot;,&quot;21S&quot;]</span><br><span class="line">    输出：[4,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">    输入：board = [&quot;E11&quot;,&quot;XXX&quot;,&quot;11S&quot;]</span><br><span class="line">    输出：[0,0]</span><br></pre></td></tr></table></figure>
<p>挺简单的, 应该不算hard. 比较烦的也就是从右下到左上, 以及全图都是字符串需要额外处理. 次数的话每次检测最大值的时候顺手算一下多少输入源可获得最大值, 然后频率加上去就行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathsWithMaxScore</span>(<span class="params">self, board: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        board[<span class="number">0</span>] = <span class="string">&#x27;0&#x27;</span>+board[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line">        board[-<span class="number">1</span>] = board[-<span class="number">1</span>][:-<span class="number">1</span>]+<span class="string">&#x27;0&#x27;</span></span><br><span class="line">        dp[-<span class="number">1</span>] = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            new_dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                    new_dp[j][<span class="number">0</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == n-<span class="number">1</span>:</span><br><span class="line">                        new_dp[j][<span class="number">0</span>] = dp[j][<span class="number">0</span>] + <span class="built_in">int</span>(board[i][j])</span><br><span class="line">                        new_dp[j][<span class="number">1</span>] = dp[j][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> i == m-<span class="number">1</span>:</span><br><span class="line">                            new_dp[j][<span class="number">0</span>] = new_dp[j+<span class="number">1</span>][<span class="number">0</span>] + <span class="built_in">int</span>(board[i][j])</span><br><span class="line">                            new_dp[j][<span class="number">1</span>] = new_dp[j+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            max_ = <span class="built_in">max</span>(dp[j][<span class="number">0</span>],new_dp[j+<span class="number">1</span>][<span class="number">0</span>],dp[j+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                            <span class="keyword">if</span> dp[j][<span class="number">0</span>] == max_:</span><br><span class="line">                                new_dp[j][<span class="number">1</span>] += dp[j][<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">if</span> dp[j+<span class="number">1</span>][<span class="number">0</span>] == max_:</span><br><span class="line">                                new_dp[j][<span class="number">1</span>] += dp[j+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">if</span> new_dp[j+<span class="number">1</span>][<span class="number">0</span>] == max_:</span><br><span class="line">                                new_dp[j][<span class="number">1</span>] += new_dp[j+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                            new_dp[j][<span class="number">0</span>] = max_ + <span class="built_in">int</span>(board[i][j])</span><br><span class="line">            dp = new_dp</span><br><span class="line">        res = dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> [res[<span class="number">0</span>]%mod,res[<span class="number">1</span>]%mod]</span><br></pre></td></tr></table></figure>
<h3 id="矩阵中和能被-k-整除的路径">2435. 矩阵中和能被 K 整除的路径</h3>
<p>给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k 。你从起点 (0, 0) 出发，每一步只能往 下 或者往 右 ，你想要到达终点 (m - 1, n - 1) 。</p>
<p>请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 109 + 7 取余 的结果。</p>
<p>示例 1：</p>
<p><img src="2435_1.png" /></p>
<p>输入：grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3<br />
输出：2<br />
解释：有两条路径满足路径上元素的和能被 k 整除。<br />
第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。<br />
第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。</p>
<p>示例 2：</p>
<p><img src="2435_2.png" /></p>
<p>输入：grid = [[0,0]], k = 5<br />
输出：1<br />
解释：红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。</p>
<p>示例 3：</p>
<p><img src="2435_3.png" /></p>
<p>输入：grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1<br />
输出：10<br />
解释：每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。</p>
<p>三层嵌套, dp里面每个元素是一个长度为k的列表, 每次读入数据的时候先合并染后shift一下.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfPaths</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="keyword">for</span> _j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_ += grid[<span class="number">0</span>][j]</span><br><span class="line">            dp[j][sum_%k] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            new_dp = [[<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="keyword">for</span> _j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                    up_l = dp[j][l]</span><br><span class="line">                    left_l = new_dp[j-<span class="number">1</span>][l] <span class="keyword">if</span> j != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    new_dp[j][(l+grid[i][j])%k] += up_l + left_l</span><br><span class="line">            dp = new_dp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>] % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="地下城游戏">174. 地下城游戏</h3>
<p>恶魔们抓住了公主并将她关在了地下城 dungeon 的 右下角 。地下城是由 m x n 个房间组成的二维网格。我们英勇的骑士最初被安置在 左上角 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快解救公主，骑士决定每次只 向右 或 向下 移动一步。</p>
<p>返回确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>注意：任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>
<p>示例 1：</p>
<p><img src="174_1.jpg" /></p>
<p>输入：dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]<br />
输出：7<br />
解释：如果骑士遵循最佳路径：右 -&gt; 右 -&gt; 下 -&gt; 下 ，则骑士的初始健康点数至少为 7 。</p>
<p>示例 2：</p>
<p>输入：dungeon = [[0]]<br />
输出：1</p>
<p>思路很不好想, 这题入口点在"从最后一格到第一格", dp记录从[m-1,n-1]到当前位置的最小值. 针对输入我们取最大值, 如果最大值大于0我们取0, 否则保持负数. 最后从dp[0]做返回.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculateMinimumHP</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[-<span class="number">1</span>] = <span class="built_in">min</span>(grid[-<span class="number">1</span>][-<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j + <span class="number">1</span>] + grid[-<span class="number">1</span>][j], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                right = dp[j + <span class="number">1</span>] <span class="keyword">if</span> j != n - <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(<span class="built_in">max</span>(right + grid[i][j], dp[j] + grid[i][j]), <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -dp[<span class="number">0</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵中的最长递增路径">329. 矩阵中的最长递增路径</h3>
<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p>示例 1：</p>
<p><img src="329_1.jpg" /></p>
<p>输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]<br />
输出：4<br />
解释：最长递增路径为 [1, 2, 6, 9]。</p>
<p>示例 2：</p>
<p><img src="329_2.jpg" /></p>
<p>输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]<br />
输出：4<br />
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</p>
<p>示例 3：</p>
<p>输入：matrix = [[1]]<br />
输出：1</p>
<p>老实说这题更像是dfs.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestIncreasingPath</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        directions = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">            max_ = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                new_x = x + dx</span><br><span class="line">                new_y = y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=new_x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=new_y&lt;n <span class="keyword">and</span> matrix[new_x][new_y] &gt; matrix[x][y]:</span><br><span class="line">                    max_ = <span class="built_in">max</span>(max_, dfs(new_x, new_y)+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> max_</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dfs(i,j))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="网格图中递增路径的数目">2328. 网格图中递增路径的数目</h3>
<p>给你一个 m x n 的整数网格图 grid ，你可以从一个格子移动到 4 个方向相邻的任意一个格子。</p>
<p>请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 10^9 + 7 取余 后返回。</p>
<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p>
<p>示例 1：</p>
<p><img src="2328_1.png" /></p>
<p>输入：grid = [[1,1],[3,4]]<br />
输出：8<br />
解释：严格递增路径包括：<br />
- 长度为 1 的路径：[1]，[1]，[3]，[4] 。<br />
- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。<br />
- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。<br />
路径数目为 4 + 3 + 1 = 8 。</p>
<p>示例 2：</p>
<p>输入：grid = [[1],[2]]<br />
输出：3<br />
解释：严格递增路径包括：<br />
- 长度为 1 的路径：[1]，[2] 。<br />
- 长度为 2 的路径：[1 -&gt; 2] 。<br />
路径数目为 2 + 1 = 3 。</p>
<p>dfs做法, 可以调cache装饰器, 但是占用内存会多一些, 自己手写一个dp表做查询更省内存.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPaths</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        directions = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp = [[-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[x][y] != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[x][y]</span><br><span class="line">            curr = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                new_x = x + dx</span><br><span class="line">                new_y = y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;= new_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; n <span class="keyword">and</span> grid[new_x][new_y] &gt; grid[x][y]:</span><br><span class="line">                    curr += dfs(new_x, new_y) % mod</span><br><span class="line">            dp[x][y] = curr % mod</span><br><span class="line">            <span class="keyword">return</span> curr % mod</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                ans += dfs(i,j) % mod</span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br></pre></td></tr></table></figure>
<p>也可以拓扑排序, 从数值最低的点开始处理.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPaths</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        directions = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        node = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                heapq.heappush(node, [grid[i][j], i, j])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _j <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            curr, x, y = heapq.heappop(node)</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                new_x = x + dx</span><br><span class="line">                new_y = y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= new_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; n <span class="keyword">and</span> grid[new_x][new_y] &lt; curr:</span><br><span class="line">                    res += dp[new_x][new_y]</span><br><span class="line">            res %= mod</span><br><span class="line">            dp[x][y] = res</span><br><span class="line">            ans += dp[x][y]</span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br></pre></td></tr></table></figure>
<h3 id="检查是否有合法括号字符串路径">2267. 检查是否有合法括号字符串路径</h3>
<p>一个括号字符串是一个 <strong>非空</strong> 且只包含 <code>'('</code> 和 <code>')'</code> 的字符串。如果下面 <strong>任意</strong> 条件为 <strong>真</strong> ，那么这个括号字符串就是 <strong>合法的</strong> 。</p>
<ul>
<li>字符串是 <code>()</code> 。</li>
<li>字符串可以表示为 <code>AB</code>（<code>A</code> 连接 <code>B</code>），<code>A</code> 和 <code>B</code> 都是合法括号序列。</li>
<li>字符串可以表示为 <code>(A)</code> ，其中 <code>A</code> 是合法括号序列。</li>
</ul>
<p>给你一个 <code>m x n</code> 的括号网格图矩阵 <code>grid</code> 。网格图中一个 <strong>合法括号路径</strong> 是满足以下所有条件的一条路径：</p>
<ul>
<li>路径开始于左上角格子 <code>(0, 0)</code> 。</li>
<li>路径结束于右下角格子 <code>(m - 1, n - 1)</code> 。</li>
<li>路径每次只会向 <strong>下</strong> 或者向 <strong>右</strong> 移动。</li>
<li>路径经过的格子组成的括号字符串是 <strong>合法</strong> 的。</li>
</ul>
<p>如果网格图中存在一条 <strong>合法括号路径</strong> ，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png" /></p>
<p><strong>输入：</strong>grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]<br />
<strong>输出：</strong>true<br />
<strong>解释：</strong>上图展示了两条路径，它们都是合法括号字符串路径。<br />
第一条路径得到的合法字符串是 "()(())" 。<br />
第二条路径得到的合法字符串是 "((()))" 。<br />
注意可能有其他的合法括号字符串路径。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png" /></p>
<p><strong>输入：</strong>grid = [[")",")"],["(","("]]<br />
<strong>输出：</strong>false<br />
<strong>解释：</strong>两条可行路径分别得到 "))(" 和 ")((" 。由于它们都不是合法括号字符串，我们返回 false 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>grid[i][j]</code> 要么是 <code>'('</code> ，要么是 <code>')'</code> 。</li>
</ul>
<p>dfs即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasValidPath</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;)&#x27;</span> <span class="keyword">or</span> grid[-<span class="number">1</span>][-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> (m+n-<span class="number">1</span>) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,l,r</span>):</span><br><span class="line">            <span class="keyword">if</span> x == m-<span class="number">1</span> <span class="keyword">and</span> y == n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> l == r + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; l <span class="keyword">or</span> l &gt; (m + n - <span class="number">1</span>) // <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            below = dfs(x+<span class="number">1</span>,y,l,r) <span class="keyword">if</span> x != m-<span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> below:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            right = dfs(x,y+<span class="number">1</span>,l,r) <span class="keyword">if</span> y != n-<span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="扣分后的最大得分">1937. 扣分后的最大得分</h3>
<p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p>
<p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p>
<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 &lt;= r &lt; m - 1</code>），选中坐标为 <code>(r, c1)</code> 和 <code>(r + 1, c2)</code> 的格子，你的总得分 <strong>减少</strong> <code>abs(c1 - c2)</code> 。</p>
<p>请你返回你能得到的 <strong>最大</strong> 得分。</p>
<p><code>abs(x)</code> 定义为：</p>
<ul>
<li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。<br />
</li>
<li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png" /></p>
<p><strong>输入：</strong>points = [[1,2,3],[1,5,1],[3,1,1]]<br />
<strong>输出：</strong>9<br />
<strong>解释：</strong><br />
蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。<br />
你的总得分增加 3 + 5 + 3 = 11 。<br />
但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。<br />
你的最终得分为 11 - 2 = 9 。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png" /></p>
<p><strong>输入：</strong>points = [[1,5],[2,3],[4,2]]<br />
<strong>输出：</strong>11<br />
<strong>解释：</strong><br />
蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。<br />
你的总得分增加 5 + 3 + 4 = 12 。<br />
但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。<br />
你的最终得分为 12 - 1 = 11 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == points.length</code></li>
<li><code>n == points[r].length</code></li>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li><code>0 &lt;= points[r][c] &lt;= 105</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-points-with-cost/description/">https://leetcode.cn/problems/maximum-number-of-points-with-cost/description/</a></p>
<p>涉及到绝对值拆分, 对于第i行k列和前一行的第j列, 我们有</p>
<p><span class="math display">\[
j &lt;  k: dp(k) = dp(j) - (k-j) + grid[i][k]  \\
j &gt;= k: dp(k) = dp(j) - (j-k) + grid[i][k]
\]</span></p>
<p>所以我们可以对某一行同时从左从右遍历.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPoints</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            new_dp = dp.copy()</span><br><span class="line">            left_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            right_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># left_max和right_max为上一行最优</span></span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max - <span class="number">1</span>, dp[j])</span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max - <span class="number">1</span>, dp[n-j-<span class="number">1</span>])</span><br><span class="line">                <span class="comment"># 上一行最大加当前格子</span></span><br><span class="line">                <span class="comment"># 由于同时从两侧, 所以new_dp[j]会被算两次, 我们取最大值.</span></span><br><span class="line">                new_dp[j] = <span class="built_in">max</span>(left_max + grid[i][j], new_dp[j])</span><br><span class="line">                new_dp[n-j-<span class="number">1</span>] = <span class="built_in">max</span>(right_max + grid[i][n-j-<span class="number">1</span>], new_dp[n-j-<span class="number">1</span>])</span><br><span class="line">            dp = new_dp</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="摘樱桃-ii">1463. 摘樱桃 II</h3>
<p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<ul>
<li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li>
<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>
<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>
<li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li>
<li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png" /></strong></p>
<p><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]<br />
<strong>输出：</strong>24<br />
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。<br />
机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。<br />
机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。<br />
樱桃总数为： 12 + 12 = 24 。</p>
<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png" /></strong></p>
<p><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]<br />
<strong>输出：</strong>28<br />
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。<br />
机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。<br />
机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。<br />
樱桃总数为： 17 + 11 = 28 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]<br />
<strong>输出：</strong>22</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>grid = [[1,1],[1,1]]<br />
<strong>输出：</strong>4</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code> </li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup-ii/description/">https://leetcode.cn/problems/cherry-pickup-ii/description/</a></p>
<p>摘樱桃1和2都挺难的, 主要是思路很难想到. 摘樱桃1主要得想到用三维dp(压缩后二维), dp[j][k]表示左机器人在j列,右机器人在k列的时候的最大值. 其他就是一个遍历, 需要注意剪枝, 想通了之后代码思路还是比较直观的.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cherryPickup</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][-<span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][-<span class="number">1</span>]</span><br><span class="line">        new_dp = copy.deepcopy(dp)</span><br><span class="line">        shift = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(i+<span class="number">1</span>,n-<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(j+<span class="number">1</span>,n-i-<span class="number">1</span>), n):</span><br><span class="line">                    max_ = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                    <span class="keyword">for</span> dj <span class="keyword">in</span> shift:</span><br><span class="line">                        <span class="keyword">for</span> dk <span class="keyword">in</span> shift:</span><br><span class="line">                            new_j = j + dj</span><br><span class="line">                            new_k = k + dk</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= new_j &lt; new_k &lt;= n-<span class="number">1</span>: </span><br><span class="line">                                max_ = <span class="built_in">max</span>(max_, dp[new_j][new_k])</span><br><span class="line">                    new_dp[j][k] = max_ + grid[i][j] + grid[i][k]</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, new_dp[j][k])</span><br><span class="line">            dp, new_dp = new_dp, dp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="摘樱桃">741. 摘樱桃</h3>
<p>给你一个 <code>n x n</code> 的网格 <code>grid</code> ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：</p>
<ul>
<li><code>0</code> 表示这个格子是空的，所以你可以穿过它。</li>
<li><code>1</code> 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>
<li><code>-1</code> 表示这个格子里有荆棘，挡着你的路。</li>
</ul>
<p>请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：</p>
<ul>
<li>从位置 <code>(0, 0)</code> 出发，最后到达 <code>(n - 1, n - 1)</code> ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 <code>0</code> 或者 <code>1</code> 的格子）；</li>
<li>当到达 <code>(n - 1, n - 1)</code> 后，你要继续走，直到返回到 <code>(0, 0)</code> ，只能向上或向左走，并且只能穿越有效的格子；</li>
<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 <code>0</code> ）；</li>
<li>如果在 <code>(0, 0)</code> 和 <code>(n - 1, n - 1)</code> 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg" /></p>
<p><strong>输入：</strong>grid = [[0,1,-1],[1,0,-1],[1,1,1]]<br />
<strong>输出：</strong>5<br />
<strong>解释：</strong>玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。<br />
在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。<br />
然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。<br />
总共捡到 5 个樱桃，这是最大可能值。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>grid = [[1,1,-1],[1,-1,1],[-1,1,1]]<br />
<strong>输出：</strong>0</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>grid[i][j]</code> 为 <code>-1</code>、<code>0</code> 或 <code>1</code></li>
<li><code>grid[0][0] != -1</code></li>
<li><code>grid[n - 1][n - 1] != -1</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/description/">https://leetcode.cn/problems/cherry-pickup/description/</a></p>
<p>首先想到可以问题转化, 从第一格到最后一格再回去, 这个问题可以转化为两个机器人同时从(0,0)出发到(m-1,n-1). 然后可以用二维dp解决.</p>
<p>但是即使如此还是有问题, 不同于摘樱桃2, 我们这里的i并不是相同的, 所以如果想要记录两个点的位置我们需要4个索引, 且不可压缩, 这种开销就有点不可接受了.</p>
<p>解决方法是我们用step数量作第一个纬度, 然后用两个机器人的列数作第二三维度. 这样机器人1的坐标就是[t-j, j], 机器人2就是[t-k,k], 这样我们就和上一题一样, 开个二维数组遍历即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cherryPickup</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n*<span class="number">2</span>-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(t,n-<span class="number">1</span>), <span class="built_in">max</span>(t-n, -<span class="number">1</span>), -<span class="number">1</span>):</span><br><span class="line">                row_j = t-j</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(t,n-<span class="number">1</span>), j-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    row_k = t-k</span><br><span class="line">                    <span class="keyword">if</span> grid[row_j][j] == -<span class="number">1</span> <span class="keyword">or</span> grid[row_k][k] == -<span class="number">1</span>:</span><br><span class="line">                        dp[j+<span class="number">1</span>][k+<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[j+<span class="number">1</span>][k+<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][k], dp[j+<span class="number">1</span>][k], dp[j][k+<span class="number">1</span>], dp[j+<span class="number">1</span>][k+<span class="number">1</span>]) + grid[row_j][j] + (grid[row_k][k] <span class="keyword">if</span> j!= k <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n][n], <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1 id="背包">背包</h1>
<h2 id="背包-1">0-1背包</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16Y411v7Y6/?share_source=copy_web&amp;vd_source=d6823da733e103cbd4bd3b52ccc7736c">【0-1背包 完全背包】</a></p>
<p>可以看下灵神怎么写代码的, 思路怎么转, 问题如何转化, 复杂度如何优化都非常精彩.</p>
<h3 id="和为目标值的最长子序列的长度">2915. 和为目标值的最长子序列的长度</h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>返回和为 <code>target</code> 的 <code>nums</code> 子序列中，子序列 <strong>长度的最大值</strong> 。如果不存在和为 <code>target</code> 的子序列，返回 <code>-1</code> 。</p>
<p><strong>子序列</strong> 指的是从原数组中删除一些或者不删除任何元素后，剩余元素保持原来的顺序构成的数组。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [1,2,3,4,5], target = 9<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>总共有 3 个子序列的和为 9 ：[4,5] ，[1,3,5] 和 [2,3,4] 。最长的子序列是 [1,3,5] 和 [2,3,4] 。所以答案为 3 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [4,1,3,2,1,5], target = 7<br />
<strong>输出：</strong>4<br />
<strong>解释：</strong>总共有 5 个子序列的和为 7 ：[4,3] ，[4,1,2] ，[4,2,1] ，[1,1,5] 和 [1,3,2,1] 。最长子序列为 [1,3,2,1] 。所以答案为 4 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>nums = [1,1,5,4,5], target = 3<br />
<strong>输出：</strong>-1<br />
<strong>解释：</strong>无法得到和为 3 的子序列。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/description/">https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/description/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubsequence</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [-inf] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target,-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= x <span class="keyword">and</span> dp[j] &lt; dp[j-x] + <span class="number">1</span>:</span><br><span class="line">                    dp[j] = dp[j-x] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="分割等和子集">416. 分割等和子集</h3>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [1,5,11,5]<br />
<strong>输出：</strong>true<br />
<strong>解释：</strong>数组可以分割成 [1, 5, 5] 和 [11] 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [1,2,3,5]<br />
<strong>输出：</strong>false<br />
<strong>解释：</strong>数组不能分割成两个元素和相等的子集。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=x:</span><br><span class="line">                    dp[j] = dp[j-x] <span class="keyword">or</span> dp[j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="目标和">494. 目标和</h3>
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [1,1,1,1,1], target = 3<br />
<strong>输出：</strong>5<br />
<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。<br />
-1 + 1 + 1 + 1 + 1 = 3<br />
+1 - 1 + 1 + 1 + 1 = 3<br />
+1 + 1 - 1 + 1 + 1 = 3<br />
+1 + 1 + 1 - 1 + 1 = 3<br />
+1 + 1 + 1 + 1 - 1 = 3</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [1], target = 1<br />
<strong>输出：</strong>1</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 20</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">https://leetcode.cn/problems/target-sum/description/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># p - (sum_-p) == target</span></span><br><span class="line">        <span class="comment"># p == (target + sum_) // 2</span></span><br><span class="line">        target += sum_</span><br><span class="line">        <span class="keyword">if</span> target % <span class="number">2</span> <span class="keyword">or</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        target = target // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=x:</span><br><span class="line">                    dp[j] += dp[j-x]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="将一个数字表示成幂的和的方案数">2787. 将一个数字表示成幂的和的方案数</h3>
<p>给你两个 <strong>正</strong> 整数 <code>n</code> 和 <code>x</code> 。</p>
<p>请你返回将 <code>n</code> 表示成一些 <strong>互不相同</strong> 正整数的 <code>x</code> 次幂之和的方案数。换句话说，你需要返回互不相同整数 <code>[n1, n2, ..., nk]</code> 的集合数目，满足 <code>n = n1x + n2x + ... + nkx</code> 。</p>
<p>由于答案可能非常大，请你将它对 <code>109 + 7</code> 取余后返回。</p>
<p>比方说，<code>n = 160</code> 且 <code>x = 3</code> ，一个表示 <code>n</code> 的方法是 <code>n = 23 + 33 + 53</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>n = 10, x = 2<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong>我们可以将 n 表示为：n = 32 + 12 = 10 。<br />
这是唯一将 10 表达成不同整数 2 次方之和的方案。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>n = 4, x = 1<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>我们可以将 n 按以下方案表示：<br />
- n = 41 = 4 。<br />
- n = 31 + 11 = 4 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>1 &lt;= x &lt;= 5</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/description/">https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/description/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, n: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gen_lst</span>(<span class="params">n, x</span>):</span><br><span class="line">            lst = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                tmp = <span class="built_in">pow</span>(i,x)</span><br><span class="line">                <span class="keyword">if</span> tmp &lt;= n:</span><br><span class="line">                    lst.append(tmp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> lst</span><br><span class="line">        nums = gen_lst(n,x)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=v:</span><br><span class="line">                    dp[j] += dp[j-v] % mod</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] % mod</span><br></pre></td></tr></table></figure>
<h3 id="执行操作可获得的最大总奖励-i">3180. 执行操作可获得的最大总奖励 I</h3>
<p>给你一个整数数组 <code>rewardValues</code>，长度为 <code>n</code>，代表奖励的值。</p>
<p>最初，你的总奖励 <code>x</code> 为 0，所有下标都是 <strong>未标记</strong> 的。你可以执行以下操作 <strong>任意次</strong> ：</p>
<ul>
<li>从区间 <code>[0, n - 1]</code> 中选择一个 <strong>未标记</strong> 的下标 <code>i</code>。<br />
</li>
<li>如果 <code>rewardValues[i]</code> <strong>大于</strong> 你当前的总奖励 <code>x</code>，则将 <code>rewardValues[i]</code> 加到 <code>x</code> 上（即 <code>x = x + rewardValues[i]</code>），并 <strong>标记</strong> 下标 <code>i</code>。</li>
</ul>
<p>以整数形式返回执行最优操作能够获得的 <strong>最大</strong> 总奖励。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>rewardValues = [1,1,3,3]</p>
<p><strong>输出：</strong>4</p>
<p><strong>解释：</strong></p>
<p>依次标记下标 0 和 2，总奖励为 4，这是可获得的最大值。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>rewardValues = [1,6,4,3,2]</p>
<p><strong>输出：</strong>11</p>
<p><strong>解释：</strong></p>
<p>依次标记下标 0、2 和 1。总奖励为 11，这是可获得的最大值。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= rewardValues.length &lt;= 2000</code></li>
<li><code>1 &lt;= rewardValues[i] &lt;= 2000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-total-reward-using-operations-i/description/">https://leetcode.cn/problems/maximum-total-reward-using-operations-i/description/</a></p>
<p>最简单的版本是0-1背包, 但是其实可以用bitset优化.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTotalReward</span>(<span class="params">self, rewardValues: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rewardValues.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(rewardValues)</span><br><span class="line">        target = rewardValues[-<span class="number">1</span>] * <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> rewardValues:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=i <span class="keyword">and</span> j - i&lt; i:</span><br><span class="line">                    dp[j] |= dp[j-i]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i]:</span><br><span class="line">                ans = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>bitset思路就是每次读入reward,保留最低的reward位, 将其左移reward位, 然后和最后的f做或运算.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTotalReward</span>(<span class="params">self, rewardValues: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        f = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(rewardValues)):</span><br><span class="line">            f |= (f &amp; ((<span class="number">1</span> &lt;&lt; v) - <span class="number">1</span>)) &lt;&lt; v</span><br><span class="line">        <span class="keyword">return</span> f.bit_length() - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="一和零">474. 一和零</h3>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3<br />
<strong>输出：</strong>4<br />
<strong>解释：</strong>最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。<br />
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>strs = ["10", "0", "1"], m = 1, n = 1<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>最大的子集是 {"0", "1"} ，所以答案是 2 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 600</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅由 <code>'0'</code> 和 <code>'1'</code> 组成</li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/">https://leetcode.cn/problems/ones-and-zeroes/description/</a></p>
<p>三维dp,压缩到二维.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxForm</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            strs[i] = Counter(strs[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> ctr <span class="keyword">in</span> strs:</span><br><span class="line">            zeros = ctr[<span class="string">&#x27;0&#x27;</span>]</span><br><span class="line">            ones = ctr[<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= zeros:</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> j &gt;= ones:</span><br><span class="line">                            dp[i][j] = <span class="built_in">max</span>(dp[i-zeros][j-ones] + <span class="number">1</span>, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="最后一块石头的重量-ii">1049. 最后一块石头的重量 II</h3>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；<br />
</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>stones = [2,7,4,1,8,1]<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong><br />
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br />
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br />
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br />
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>stones = [31,26,33,21,40]<br />
<strong>输出：</strong>5</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></p>
<p>非常直观的0-1背包, 目标是取总数一半的值, 总会有一边小于一半, 所以我们直接开一个sum//2的数组就可以了.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastStoneWeightII</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(stones)</span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> stones:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= s:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j-s] + s)</span><br><span class="line">        <span class="keyword">return</span> sum_ - <span class="number">2</span> * dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="最接近目标价格的甜点成本">1774. 最接近目标价格的甜点成本</h3>
<p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code> 种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>
<ul>
<li>必须选择 <strong>一种</strong> 冰激凌基料。<br />
</li>
<li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。<br />
</li>
<li>每种类型的配料 <strong>最多两份</strong> 。</li>
</ul>
<p>给你以下三个输入：</p>
<ul>
<li><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code> 表示第 <code>i</code> 种冰激凌基料的价格。<br />
</li>
<li><code>toppingCosts</code>，一个长度为 <code>m</code> 的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 <strong>一份</strong> 第 <code>i</code> 种冰激凌配料的价格。<br />
</li>
<li><code>target</code> ，一个整数，表示你制作甜点的目标价格。</li>
</ul>
<p>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code> 。</p>
<p>返回最接近 <code>target</code> 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>baseCosts = [1,7], toppingCosts = [3,4], target = 10<br />
<strong>输出：</strong>10<br />
<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：<br />
- 选择 1 号基料：成本 7<br />
- 选择 1 份 0 号配料：成本 1 x 3 = 3<br />
- 选择 0 份 1 号配料：成本 0 x 4 = 0<br />
总成本：7 + 3 + 0 = 10 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>baseCosts = [2,3], toppingCosts = [4,5,100], target = 18<br />
<strong>输出：</strong>17<br />
<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：<br />
- 选择 1 号基料：成本 3<br />
- 选择 1 份 0 号配料：成本 1 x 4 = 4<br />
- 选择 2 份 1 号配料：成本 2 x 5 = 10<br />
- 选择 0 份 2 号配料：成本 0 x 100 = 0<br />
总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>baseCosts = [3,10], toppingCosts = [2,5], target = 9<br />
<strong>输出：</strong>8<br />
<strong>解释：</strong>可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>baseCosts = [10], toppingCosts = [1], target = 1<br />
<strong>输出：</strong>10<br />
<strong>解释：</strong>注意，你可以选择不添加任何配料，但你必须选择一种基料。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == baseCosts.length</code></li>
<li><code>m == toppingCosts.length</code></li>
<li><code>1 &lt;= n, m &lt;= 10</code></li>
<li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 104</code></li>
<li><code>1 &lt;= target &lt;= 104</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/closest-dessert-cost/description/">https://leetcode.cn/problems/closest-dessert-cost/description/</a></p>
<p>记忆化搜索会简单一些, dp也可以.</p>
<p>dfs做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closestCost</span>(<span class="params">self, baseCosts: <span class="type">List</span>[<span class="built_in">int</span>], toppingCosts: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        toppingCosts += toppingCosts</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):</span><br><span class="line">            <span class="keyword">if</span> c &gt;= target <span class="keyword">or</span> i == <span class="built_in">len</span>(toppingCosts):</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            include = dfs(i+<span class="number">1</span>, c+toppingCosts[i])</span><br><span class="line">            exclude = dfs(i+<span class="number">1</span>, c)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(include - target) &lt; <span class="built_in">abs</span>(exclude - target):</span><br><span class="line">                <span class="keyword">return</span> include</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(include - target) &gt; <span class="built_in">abs</span>(exclude - target):</span><br><span class="line">                <span class="keyword">return</span> exclude</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(include, exclude)</span><br><span class="line">        ans = baseCosts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> base <span class="keyword">in</span> baseCosts:</span><br><span class="line">            res = dfs(<span class="number">0</span>,base)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(res-target) &lt;= <span class="built_in">abs</span>(ans-target):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(res-target) &lt; <span class="built_in">abs</span>(ans-target):</span><br><span class="line">                    ans = res</span><br><span class="line">                <span class="keyword">elif</span> res &lt; ans:</span><br><span class="line">                    ans = res</span><br><span class="line">        <span class="keyword">return</span> ans          </span><br></pre></td></tr></table></figure>
<p>dp做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closestCost</span>(<span class="params">self, baseCosts: <span class="type">List</span>[<span class="built_in">int</span>], toppingCosts: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">first, second, target</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(first - target) &lt; <span class="built_in">abs</span>(second-target):</span><br><span class="line">                <span class="keyword">return</span> first</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(first - target) &gt; <span class="built_in">abs</span>(second-target):</span><br><span class="line">                <span class="keyword">return</span> second</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(first,second)</span><br><span class="line"></span><br><span class="line">        max_ = <span class="built_in">max</span>(toppingCosts)</span><br><span class="line">        toppingCosts += toppingCosts</span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> base <span class="keyword">in</span> baseCosts:</span><br><span class="line">            new_target = target - base</span><br><span class="line">            <span class="keyword">if</span> new_target &gt;= <span class="number">0</span>:</span><br><span class="line">                dp = [<span class="literal">False</span>] * (new_target + max_ + <span class="number">1</span>)</span><br><span class="line">                dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> top <span class="keyword">in</span> toppingCosts:</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_target+max_,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> j &gt;= top:</span><br><span class="line">                            dp[j] |= dp[j-top]</span><br><span class="line">                <span class="keyword">if</span> dp[new_target]:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> new_target - i &gt;= <span class="number">0</span> <span class="keyword">or</span> new_target + i &lt;= new_target + max_:</span><br><span class="line">                        <span class="keyword">if</span> new_target - i &gt;= <span class="number">0</span> <span class="keyword">and</span> dp[new_target-i]:</span><br><span class="line">                            ans = <span class="keyword">match</span>(ans, target - i, target)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> new_target + i &lt;= new_target + max_ <span class="keyword">and</span> dp[new_target+i]:</span><br><span class="line">                            ans = <span class="keyword">match</span>(ans, target + i, target)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">            ans = <span class="keyword">match</span>(ans, base, target)</span><br><span class="line">        <span class="keyword">return</span> ans       </span><br></pre></td></tr></table></figure>
<h3 id="盈利计划">879. 盈利计划</h3>
<p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>
<p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> <code>10^9 + 7</code> <strong>的值</strong>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。<br />
总的来说，有两种计划。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]<br />
<strong>输出：</strong>7<br />
<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。<br />
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= minProfit &lt;= 100</code></li>
<li><code>1 &lt;= group.length &lt;= 100</code></li>
<li><code>1 &lt;= group[i] &lt;= 100</code></li>
<li><code>profit.length == group.length</code></li>
<li><code>0 &lt;= profit[i] &lt;= 100</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/profitable-schemes/description/">https://leetcode.cn/problems/profitable-schemes/description/</a></p>
<p>比较标准的背包, 同时涉及profit和cost的时候开二维数组.</p>
<p>dfs写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">profitableSchemes</span>(<span class="params">self, n: <span class="built_in">int</span>, minProfit: <span class="built_in">int</span>, group: <span class="type">List</span>[<span class="built_in">int</span>], profit: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        pre_sum = <span class="built_in">list</span>(accumulate([<span class="number">0</span>]+group))</span><br><span class="line">        length = <span class="built_in">len</span>(profit)</span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c, n_</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= length:</span><br><span class="line">                <span class="keyword">if</span> c == minProfit:</span><br><span class="line">                    <span class="keyword">if</span> n &gt;= pre_sum[-<span class="number">1</span>] - pre_sum[i]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">2</span>**(length-i)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> n_ == <span class="number">0</span> <span class="keyword">and</span> c &lt; minProfit:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            include = dfs(i+<span class="number">1</span>, <span class="built_in">min</span>(c+profit[i], minProfit), n_-group[i]) <span class="keyword">if</span> n_ &gt;= group[i] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            exclude = dfs(i+<span class="number">1</span>, <span class="built_in">min</span>(c, minProfit), n_)</span><br><span class="line">            <span class="keyword">return</span> include + exclude</span><br><span class="line"></span><br><span class="line">        ans = dfs(<span class="number">0</span>,<span class="number">0</span>,n)</span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br></pre></td></tr></table></figure>
<p>dp写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">profitableSchemes</span>(<span class="params">self, n: <span class="built_in">int</span>, minProfit: <span class="built_in">int</span>, group: <span class="type">List</span>[<span class="built_in">int</span>], profit: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        length = <span class="built_in">len</span>(profit)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(minProfit+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            p = profit[i]</span><br><span class="line">            g = group[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(minProfit, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> k &gt;= g:</span><br><span class="line">                        dp[j][k] += dp[<span class="built_in">max</span>(j-p,<span class="number">0</span>)][k-g] % mod</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(dp[minProfit]) % mod</span><br></pre></td></tr></table></figure>
<h3 id="求出所有子序列的能量和">3082. 求出所有子序列的能量和</h3>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>
<p>一个整数数组的 <strong>能量</strong> 定义为和 <strong>等于</strong> <code>k</code> 的子序列的数目。</p>
<p>请你返回 <code>nums</code> 中所有子序列的 <strong>能量和</strong> 。</p>
<p>由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> nums = [1,2,3], k = 3</p>
<p><strong>输出：</strong> 6</p>
<p><strong>解释：</strong></p>
<p>总共有 <code>5</code> 个能量不为 0 的子序列：</p>
<ul>
<li>子序列 <code>[_**1**_,_**2**_,_**3**_]</code> 有 <code>2</code> 个和为 <code>3</code> 的子序列：<code>[1,2,**_3_**]</code> 和 <code>[**_1_**,**_2_**,3]</code> 。<br />
</li>
<li>子序列 <code>[_**1**_,2,_**3**_]</code> 有 <code>1</code> 个和为 <code>3</code> 的子序列：<code>[1,2,**_3_**]</code> 。<br />
</li>
<li>子序列 <code>[1,_**2**_,_**3**_]</code> 有 <code>1</code> 个和为 <code>3</code> 的子序列：<code>[1,2,**_3_**]</code> 。<br />
</li>
<li>子序列 <code>[_**1**_,_**2**_,3]</code> 有 <code>1</code> 个和为 <code>3</code> 的子序列：<code>[**_1_**,**_2_**,3]</code> 。<br />
</li>
<li>子序列 <code>[1,2,_**3**_]</code> 有 <code>1</code> 个和为 <code>3</code> 的子序列：<code>[1,2,**_3_**]</code> 。</li>
</ul>
<p>所以答案为 <code>2 + 1 + 1 + 1 + 1 = 6</code> 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> nums = [2,3,3], k = 5</p>
<p><strong>输出：</strong> 4</p>
<p><strong>解释：</strong></p>
<p>总共有 <code>3</code> 个能量不为 0 的子序列：</p>
<ul>
<li>子序列 <code>[_**2**_,_**3**_,_**3**_]</code> 有 2 个子序列和为 <code>5</code> ：<code>[**_2_**,3,**_3_**]</code> 和 <code>[**_2_**,**_3_**,3]</code> 。<br />
</li>
<li>子序列 <code>[_**2**_,3,_**3**_]</code> 有 1 个子序列和为 <code>5</code> ：<code>[**_2_**,3,**_3_**]</code> 。<br />
</li>
<li>子序列 <code>[_**2**_,_**3**_,3]</code> 有 1 个子序列和为 <code>5</code> ：<code>[**_2_**,**_3_**,3]</code> 。</li>
</ul>
<p>所以答案为 <code>2 + 1 + 1 = 4</code> 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> nums = [1,2,3], k = 7</p>
<p><strong>输出：</strong> 0</p>
<p><strong>解释：</strong>不存在和为 <code>7</code> 的子序列，所以 <code>nums</code> 的能量和为 <code>0</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= k &lt;= 100</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/description/">https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/description/</a></p>
<p>首先是思路会比较难想到, 对于所有长度为j且和为k的子序列, 它其实可以提供2^(n-j)个可能. 因此我们可以把长度看作cost, k看作value做0-1背包, 代码大致和上面那题相似, 不过最后需要遍历一遍length.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfPower</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (length+<span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(length, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= i <span class="keyword">and</span> l &gt;= <span class="number">1</span>:</span><br><span class="line">                        dp[j][l] += dp[j-i][l-<span class="number">1</span>] % mod</span><br><span class="line"></span><br><span class="line">        curr = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(length, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            ans += curr * dp[k][l] % mod</span><br><span class="line">            curr *= <span class="number">2</span> % mod</span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br></pre></td></tr></table></figure>
<p>意识到length其实也可以继续压缩, 两种思路.</p>
<ol type="1">
<li><p>一是基于上面的源码, 可以看到最终结果涉及到dp[j][l-1]乘以2加到ans, 可以把乘以2直接提出来丢到转移方程里面, 这样可以直接把l这个纬度压缩掉,同时最终结果直接取dp[-1]即可.</p></li>
<li><p>通过逻辑分析, 假设nums全集为U, 我们选择的数字构成集合T, 集合T中我们选出集合S来组成k. 那么存在几种情况.<br />
</p></li>
</ol>
<ul>
<li>数字nums[i]不在T里面, 那么我们相当于直接无视掉nums[i], 即f[i][j] = f[i-1][j].<br />
</li>
<li>数字nums[i]在T里面但是不在S里面, 那么我们还是相当于没用nums[i]来构成k, 即f[i][j] = f[i-1][j].<br />
</li>
<li>数字nums[i]在S里面, 那么f[i][j] = f[i-1][j-nums[i-1]].</li>
</ul>
<p>可以看到结论是相同的.</p>
<p>优化代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfPower</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (k+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] = (dp[j] * <span class="number">2</span>) % mod</span><br><span class="line">                <span class="keyword">if</span> j &gt;= i:</span><br><span class="line">                    dp[j] += dp[j-i] % mod</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] % mod</span><br></pre></td></tr></table></figure>
<h3 id="最高的广告牌">956. 最高的广告牌</h3>
<p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p>
<p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code> 的支架。</p>
<p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>[1,2,3,6]<br />
<strong>输出：</strong>6<br />
<strong>解释：</strong>我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>[1,2,3,4,5,6]<br />
<strong>输出：</strong>10<br />
<strong>解释：</strong>我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>[1,2]<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>没法安装广告牌，所以返回 0。</p>
<p><strong>提示：</strong></p>
<ol type="1">
<li><code>0 &lt;= rods.length &lt;= 20</code></li>
<li><code>1 &lt;= rods[i] &lt;= 1000</code></li>
<li><code>sum(rods[i]) &lt;= 5000</code></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/tallest-billboard/description/">https://leetcode.cn/problems/tallest-billboard/description/</a></p>
<p>构造数组, dp[j]表示的是两者相差j的时候较短的rod的大小. 表示较长的rod也是一样的, 主要是要想到表示的是什么.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tallestBillboard</span>(<span class="params">self, rods: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(rods)</span><br><span class="line">        target = sum_</span><br><span class="line">        <span class="comment"># dp表示相差为j的状态, 较短的rod的大小</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        new_dp = dp.copy()</span><br><span class="line">        <span class="keyword">for</span> rod <span class="keyword">in</span> rods:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">                new_dp[j] = <span class="built_in">max</span>(dp[j], new_dp[j])</span><br><span class="line">                <span class="comment"># rod加到长的那一截</span></span><br><span class="line">                <span class="keyword">if</span> j+rod&lt;= target:</span><br><span class="line">                    new_dp[j+rod] = <span class="built_in">max</span>(new_dp[j+rod], dp[j])</span><br><span class="line">                <span class="comment"># rod加到短的那一截</span></span><br><span class="line">                new_dp[<span class="built_in">abs</span>(j-rod)] = <span class="built_in">max</span>(new_dp[<span class="built_in">abs</span>(j-rod)], dp[j] + <span class="built_in">min</span>(j,rod))</span><br><span class="line">                </span><br><span class="line">            new_dp, dp = dp, new_dp</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="好分区的数目">2518. 好分区的数目</h3>
<p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p>
<p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>109 + 7</code> <strong>取余</strong> 后的结果。</p>
<p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [1,2,3,4], k = 4<br />
<strong>输出：</strong>6<br />
<strong>解释：</strong>好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [3,3,3], k = 4<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>数组中不存在好分区。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>nums = [6,6], k = 2<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>可以将 nums[0] 放入第一个分区或第二个分区中。<br />
好分区的情况是 ([6], [6]) 和 ([6], [6]) 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-great-partitions/description/">https://leetcode.cn/problems/number-of-great-partitions/description/</a></p>
<p>直观思路很简单, 但其实会TLE.</p>
<p>直观思路: 要求两个分组都大于k,那么我们可以有 <code>k &lt;= group_sum &lt;= sum(nums) - k</code>, 从而我们可以直接0-1背包,然后求区间和. 但是这里有一个问题, sum可能会非常大, 乘上去计算量过大导致直接超时.</p>
<p>所以这里需要转化一下, 我们直接反过来求小于k的值, 乘以二就是两边的值, 然后全集减一下得到答案.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPartitions</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">if</span> sum_ &lt; <span class="number">2</span> * k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span>(nums) &gt;= k:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> ** <span class="built_in">len</span>(nums) - <span class="number">2</span>) % mod</span><br><span class="line">        <span class="comment"># k &lt;= x &lt;= sum - k</span></span><br><span class="line">        min_ = <span class="built_in">min</span>(k, sum_ - k)</span><br><span class="line">        dp = [<span class="number">0</span>] * (min_ + <span class="number">1</span>) </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(min_, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">                    dp[j] = (dp[j] + dp[j - i]) % mod</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="number">2</span> ** <span class="built_in">len</span>(nums)) - <span class="built_in">sum</span>(dp[:min_])*<span class="number">2</span>) % mod</span><br></pre></td></tr></table></figure>
<h3 id="给墙壁刷油漆">2742. 给墙壁刷油漆</h3>
<p>给你两个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>cost</code> 和 <code>time</code> ，分别表示给 <code>n</code> 堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：</p>
<ul>
<li>一位需要 <strong>付费</strong> 的油漆匠，刷第 <code>i</code> 堵墙需要花费 <code>time[i]</code> 单位的时间，开销为 <code>cost[i]</code> 单位的钱。<br />
</li>
<li>一位 <strong>免费</strong> 的油漆匠，刷 <strong>任意</strong> 一堵墙的时间为 <code>1</code> 单位，开销为 <code>0</code> 。但是必须在付费油漆匠 <strong>工作</strong> 时，免费油漆匠才会工作。</li>
</ul>
<p>请你返回刷完 <code>n</code> 堵墙最少开销为多少。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>cost = [1,2,3,2], time = [1,2,3,2]<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>下标为 0 和 1 的墙由付费油漆匠来刷，需要 3 单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0 。总开销为 1 + 2 = 3 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>cost = [2,3,4,2], time = [1,1,1,1]<br />
<strong>输出：</strong>4<br />
<strong>解释：</strong>下标为 0 和 3 的墙由付费油漆匠来刷，需要 2 单位时间。同时，免费油漆匠刷下标为 1 和 2 的墙，需要 2 单位时间，开销为 0 。总开销为 2 + 2 = 4 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= cost.length &lt;= 500</code></li>
<li><code>cost.length == time.length</code></li>
<li><code>1 &lt;= cost[i] &lt;= 106</code></li>
<li><code>1 &lt;= time[i] &lt;= 500</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/painting-the-walls/description/">https://leetcode.cn/problems/painting-the-walls/description/</a></p>
<p>记忆化搜索</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paintWalls</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>], time: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, finished</span>):</span><br><span class="line">            <span class="keyword">if</span> finished &gt;= n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="comment"># 选i</span></span><br><span class="line">            include = dfs(i+<span class="number">1</span>, finished + <span class="number">1</span> + time[i]) + cost[i]</span><br><span class="line">            <span class="comment"># 不选</span></span><br><span class="line">            exclude = dfs(i+<span class="number">1</span>, finished)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(include, exclude)</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>dp写法,需要注意里面是dp[max(j-time[i]-1,0)],而不是对j和i做判断. 因为time[i]过大的时候也是符合题意的, 所以把这种情况归纳到dp[0]上面.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paintWalls</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>], time: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[<span class="built_in">max</span>(j-time[i]-<span class="number">1</span>, <span class="number">0</span>)] + cost[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="lcp-47.-入场安检">LCP 47. 入场安检</h3>
<p>「力扣挑战赛」 的入场仪式马上就要开始了，由于安保工作的需要，设置了可容纳人数总和为 <code>M</code> 的 <code>N</code> 个安检室，<code>capacities[i]</code> 记录第 <code>i</code> 个安检室可容纳人数。安检室拥有两种类型：</p>
<ul>
<li>先进先出：在安检室中的所有观众中，最早进入安检室的观众最先离开<br />
</li>
<li>后进先出：在安检室中的所有观众中，最晚进入安检室的观众最先离开</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1628843202-cdFPSt-c24754f1a5ff56989340ba5004dc5eda.gif" /></p>
<p>恰好 <code>M+1</code> 位入场的观众（编号从 0 开始）需要排队<strong>依次</strong>入场安检， 入场安检的规则如下：</p>
<ul>
<li>观众需要先进入编号 <code>0</code> 的安检室<br />
</li>
<li>当观众将进入编号 <code>i</code> 的安检室时（<code>0 &lt;= i &lt; N</code>)，
<ul>
<li>若安检室未到达可容纳人数上限，该观众可直接进入；<br />
</li>
<li>若安检室已到达可容纳人数上限，在该观众进入安检室之前需根据当前安检室类型选择一位观众离开后才能进入；<br />
</li>
</ul></li>
<li>当观众离开编号 <code>i</code> 的安检室时 （<code>0 &lt;= i &lt; N-1</code>)，将进入编号 <code>i+1</code> 的安检室接受安检。</li>
</ul>
<p>若可以任意设定每个安检室的类型，请问有多少种设定安检室类型的方案可以使得编号 <code>k</code> 的观众第一个通过最后一个安检室入场。</p>
<p><strong>注意：</strong></p>
<ul>
<li>观众不可主动离开安检室，只有当安检室容纳人数达到上限，且又有新观众需要进入时，才可根据安检室的类型选择一位观众离开；<br />
</li>
<li>由于方案数可能过大，请将答案对 <code>1000000007</code> 取模后返回。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>capacities = [2,2,3], k = 2</code></p>
<p>输出：<code>2</code> 解释： 存在两种设定的 <code>2</code> 种方案：</p>
<ul>
<li>方案 1：将编号为 <code>0</code> 、<code>1</code> 的实验室设置为 <strong>后进先出</strong> 的类型，编号为 <code>2</code> 的实验室设置为 <strong>先进先出</strong> 的类型；<br />
</li>
<li>方案 2：将编号为 <code>0</code> 、<code>1</code> 的实验室设置为 <strong>先进先出</strong> 的类型，编号为 <code>2</code> 的实验室设置为 <strong>后进先出</strong> 的类型。</li>
</ul>
<p>以下是方案 1 的示意图： <img src="https://pic.leetcode-cn.com/1628841618-bFKsnt-c60e38199a225ad62f13b954872edf9b.gif" /></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>capacities = [3,3], k = 3</code></p>
<p>输出：<code>0</code></p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>capacities = [4,3,2,2], k = 6</code></p>
<p>输出：<code>2</code></p>
</blockquote>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= capacities.length &lt;= 200</code></li>
<li><code>1 &lt;= capacities[i] &lt;= 200</code></li>
<li><code>0 &lt;= k &lt;= sum(capacities)</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/oPs9Bm/description/">https://leetcode.cn/problems/oPs9Bm/description/</a></p>
<p>可以直接手动全翻转一遍, 注意剪枝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">securityCheck</span>(<span class="params">self, capacities: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        prev = <span class="built_in">list</span>(accumulate([<span class="number">0</span>]+capacities[::-<span class="number">1</span>]))[::-<span class="number">1</span>]</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, before</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> before == <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i != n-<span class="number">1</span> <span class="keyword">and</span> before &gt; prev[i] + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 翻转当前</span></span><br><span class="line">            <span class="comment"># before + 1 &gt;= capacity[i] -&gt; before -= (capacity[i] - 1)</span></span><br><span class="line">            <span class="keyword">if</span> before - capacities[i] + <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                flip = dfs(i+<span class="number">1</span>, before - capacities[i] + <span class="number">1</span>) % mod_v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flip = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 不翻转</span></span><br><span class="line">            ignore = dfs(i+<span class="number">1</span>, before) % mod_v</span><br><span class="line">            <span class="keyword">return</span> (flip+ignore) % mod_v</span><br><span class="line">        n = <span class="built_in">len</span>(capacities)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,k) % mod_v</span><br></pre></td></tr></table></figure>
<p>也可以问题转化, 记容器价值为capacity-1, 然后我们的目标是选取其中任意容器组合, 使得价值为k.</p>
<p>记忆化搜索, 和上面源码几乎是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">securityCheck</span>(<span class="params">self, capacities: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(capacities)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        prev = <span class="built_in">list</span>(accumulate([<span class="number">0</span>]+capacities[::-<span class="number">1</span>]))[::-<span class="number">1</span>]</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, curr</span>):</span><br><span class="line">            <span class="keyword">if</span> curr &lt; <span class="number">0</span> <span class="keyword">or</span> curr &gt; prev[i] - (n-<span class="number">1</span>-i):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> curr == <span class="number">0</span></span><br><span class="line">            include = (dfs(i+<span class="number">1</span>, curr - capacities[i] + <span class="number">1</span>) % mod_v) <span class="keyword">if</span> capacities[i] - <span class="number">1</span> &lt;= curr <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            exclude = dfs(i+<span class="number">1</span>, curr) % mod_v</span><br><span class="line">            <span class="keyword">return</span> (include + exclude) % mod_v</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, k) % mod_v</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">securityCheck</span>(<span class="params">self, capacities: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (k+<span class="number">1</span>)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> capacities:</span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, x-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] = (dp[i] + dp[i-x]) % mod_v</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] % mod_v</span><br></pre></td></tr></table></figure>
<h2 id="完全背包">完全背包</h2>
<p>物品可以重复选, 无个数限制.</p>
<p>和0-1背包的区别:</p>
<p>0-1背包: dp[i][j] = dp[i-1][j] + dp[i-1][j-element[i]]<br />
完全背包: dp[i][j] = dp[i-1][j] + dp[i][j-element[i]]</p>
<h3 id="零钱兑换">322. 零钱兑换</h3>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br />
<strong>输出：</strong><code>3</code><br />
<strong>解释：</strong>11 = 5 + 5 + 1</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code><br />
<strong>输出：</strong>-1</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>coins = [1], amount = 0<br />
<strong>输出：</strong>0</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">https://leetcode.cn/problems/coin-change/description/</a></p>
<p>在遍历上面的区别就是遍历顺序, 完全背包有前向依赖, 所以需要正序遍历, 区别于0-1背包的反向遍历防止依赖问题.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 遍历顺序注意</span></span><br><span class="line">            <span class="comment"># 从coin到amount</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>或者改变循环的顺序也可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> i-coin &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换-ii">518. 零钱兑换 II</h3>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>amount = 5, coins = [1, 2, 5]<br />
<strong>输出：</strong>4<br />
<strong>解释：</strong>有四种方式可以凑成总金额：<br />
5=5<br />
5=2+2+1<br />
5=2+1+1+1<br />
5=1+1+1+1+1</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>amount = 3, coins = [2]<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>只用面额 2 的硬币不能凑成总金额 3 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>amount = 10, coins = [10]<br />
<strong>输出：</strong>1</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 300</code></li>
<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>
<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">https://leetcode.cn/problems/coin-change-ii/description/</a></p>
<p>和上一题一模一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i-coin]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="完全平方数">279. 完全平方数</h3>
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>n = <code>12</code><br />
<strong>输出：</strong>3<br />
<strong>解释：</strong><code>12 = 4 + 4 + 4</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>n = <code>13</code><br />
<strong>输出：</strong>2<br />
<strong>解释：</strong><code>13 = 4 + 9</code></p>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/">https://leetcode.cn/problems/perfect-squares/description/</a></p>
<p>类似思路, 不过这题有个简单的纯数学方法, 这里就不做记录了.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_ = <span class="built_in">int</span>(n ** <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> max_ * max_ == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i*i, n+<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j-i*i]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="数位成本和为目标值的最大数字">1449. 数位成本和为目标值的最大数字</h3>
<p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>
<ul>
<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。<br />
</li>
<li>总成本必须恰好等于 <code>target</code> 。<br />
</li>
<li>添加的数位中没有数字 0 。</li>
</ul>
<p>由于答案可能会很大，请你以字符串形式返回。</p>
<p>如果按照上述要求无法得到任何整数，请你返回 "0" 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9<br />
<strong>输出：</strong>"7772"<br />
<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。<br />
<strong>数字 成本</strong><br />
1 -&gt; 4<br />
2 -&gt; 3<br />
3 -&gt; 2<br />
4 -&gt; 5<br />
5 -&gt; 6<br />
6 -&gt; 7<br />
7 -&gt; 2<br />
8 -&gt; 5<br />
9 -&gt; 5</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12<br />
<strong>输出：</strong>"85"<br />
<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5<br />
<strong>输出：</strong>"0"<br />
<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47<br />
<strong>输出：</strong>"32211"</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>cost.length == 9</code></li>
<li><code>1 &lt;= cost[i] &lt;= 5000</code></li>
<li><code>1 &lt;= target &lt;= 5000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/description/">https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/description/</a></p>
<p>自己写的时候用的一个函数判断大小, 思路也还是dp.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestNumber</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">larger</span>(<span class="params">a, b</span>):</span><br><span class="line">            len_a = a.total()</span><br><span class="line">            len_b = b.total()</span><br><span class="line">            <span class="keyword">if</span> len_a &gt; len_b:</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            <span class="keyword">elif</span> len_b &gt; len_a:</span><br><span class="line">                <span class="keyword">return</span> b</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> a[i] &gt; b[i]:</span><br><span class="line">                        <span class="keyword">return</span> a</span><br><span class="line">                    <span class="keyword">elif</span> a[i] &lt; b[i]:</span><br><span class="line">                        <span class="keyword">return</span> b</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">        dp = [<span class="literal">None</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = Counter()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            num = i + <span class="number">1</span></span><br><span class="line">            v = cost[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(v, target), target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j-v] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    new_ctr = dp[j - v].copy()</span><br><span class="line">                    new_ctr[num] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> dp[j] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        dp[j]= new_ctr</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[j] = larger(new_ctr, dp[j])</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> dp[-<span class="number">1</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            ans = ans + dp[-<span class="number">1</span>][i] * <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>不过有优化的办法, 可以直接用dp求最大位数, 然后遍历9-1获取最大数字数量, 这样就不用维护Counter了.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestNumber</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> cost:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c, target + <span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dp[target] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        j = target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            c = cost[i]</span><br><span class="line">            <span class="keyword">while</span> j &gt;= c <span class="keyword">and</span> dp[j] == dp[j - c] + <span class="number">1</span>:</span><br><span class="line">                ans.append(<span class="built_in">str</span>(i + <span class="number">1</span>))</span><br><span class="line">                j -= c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
<h2 id="多重背包">多重背包</h2>
<p>物品可以重复选, 但是有数量限制</p>
<h3 id="获得分数的方法数">2585. 获得分数的方法数</h3>
<p>考试中有 <code>n</code> 种类型的题目。给你一个整数 <code>target</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>types</code> ，其中 <code>types[i] = [counti, marksi]</code> 表示第 <code>i</code> 种类型的题目有 <code>counti</code> 道，每道题目对应 <code>marksi</code> 分。</p>
<p>返回你在考试中恰好得到 <code>target</code> 分的方法数。由于答案可能很大，结果需要对 <code>109 +7</code> 取余。</p>
<p><strong>注意</strong>，同类型题目无法区分。</p>
<ul>
<li>比如说，如果有 <code>3</code> 道同类型题目，那么解答第 <code>1</code> 和第 <code>2</code> 道题目与解答第 <code>1</code> 和第 <code>3</code> 道题目或者第 <code>2</code> 和第 <code>3</code> 道题目是相同的。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>target = 6, types = [[6,1],[3,2],[2,3]]<br />
<strong>输出：</strong>7<br />
<strong>解释：</strong>要获得 6 分，你可以选择以下七种方法之一：<br />
- 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6<br />
- 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6<br />
- 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6<br />
- 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6<br />
- 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6<br />
- 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6<br />
- 解决 2 道第 2 种类型的题目：3 + 3 = 6</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>target = 5, types = [[50,1],[50,2],[50,5]]<br />
<strong>输出：</strong>4<br />
<strong>解释：</strong>要获得 5 分，你可以选择以下四种方法之一：<br />
- 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5<br />
- 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5<br />
- 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5<br />
- 解决 1 道第 2 种类型的题目：5</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>target = 18, types = [[6,1],[3,2],[2,3]]<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong>只有回答所有题目才能获得 18 分。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 1000</code></li>
<li><code>n == types.length</code></li>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>types[i].length == 2</code></li>
<li><code>1 &lt;= counti, marksi &lt;= 50</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-ways-to-earn-points/description/">https://leetcode.cn/problems/number-of-ways-to-earn-points/description/</a></p>
<p>第一层遍历group, 第二层遍历value, 意思就是从每个group里面选一个值看达到value有多少不同可能, 第三层再套一层循环算count, 表示某个group里面可以取不同值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysToReachTarget</span>(<span class="params">self, target: <span class="built_in">int</span>, types: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> count, value <span class="keyword">in</span> types:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(count, j//value), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[j] = (dp[j-k*value] + dp[j]) % mod_v</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>受到下一题前缀和的启发, 可以进一步优化. 下一题写的是遍历一遍获取列表, 这里写双向遍历但不需要额外空间的写法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysToReachTarget</span>(<span class="params">self, target: <span class="built_in">int</span>, types: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> count, value <span class="keyword">in</span> types:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(value,target+<span class="number">1</span>):</span><br><span class="line">                dp[j] = (dp[j]+dp[j-value]) % mod_v</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, value-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= value * (count + <span class="number">1</span>):</span><br><span class="line">                    dp[j] = (dp[j] - dp[j-value*(count+<span class="number">1</span>)]) % mod_v</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="和带限制的子多重集合的数目">2902. 和带限制的子多重集合的数目</h3>
<p>给你一个下标从 <strong>0</strong> 开始的非负整数数组 <code>nums</code> 和两个整数 <code>l</code> 和 <code>r</code> 。</p>
<p>请你返回 <code>nums</code> 中子多重集合的和在闭区间 <code>[l, r]</code> 之间的 <strong>子多重集合的数目</strong> 。</p>
<p>由于答案可能很大，请你将答案对 <code>109 + 7</code> 取余后返回。</p>
<p><strong>子多重集合</strong> 指的是从数组中选出一些元素构成的 <strong>无序</strong> 集合，每个元素 <code>x</code> 出现的次数可以是 <code>0, 1, ..., occ[x]</code> 次，其中 <code>occ[x]</code> 是元素 <code>x</code> 在数组中的出现次数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果两个子多重集合中的元素排序后一模一样，那么它们两个是相同的 <strong>子多重集合</strong> 。<br />
</li>
<li><strong>空</strong> 集合的和是 <code>0</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [1,2,2,3], l = 6, r = 6<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong>唯一和为 6 的子集合是 {1, 2, 3} 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [2,1,4,2,7], l = 1, r = 5<br />
<strong>输出：</strong>7<br />
<strong>解释：</strong>和在闭区间 [1, 5] 之间的子多重集合为 {1} ，{2} ，{4} ，{2, 2} ，{1, 2} ，{1, 4} 和 {1, 2, 2} 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>nums = [1,2,1,3,5,2], l = 3, r = 5<br />
<strong>输出：</strong>9<br />
<strong>解释：</strong>和在闭区间 [3, 5] 之间的子多重集合为 {3} ，{5} ，{1, 2} ，{1, 3} ，{2, 2} ，{2, 3} ，{1, 1, 2} ，{1, 1, 3} 和 {1, 2, 2} 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 2 * 104</code></li>
<li><code>nums</code> 的和不超过 <code>2 * 104</code> 。</li>
<li><code>0 &lt;= l &lt;= r &lt;= 2 * 104</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/description/">https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/description/</a></p>
<p>一开始思路是和上题一样, 也确实是可以解的, 但是问题就是复杂度太高会直接TLE. 同时需要注意0的特殊项的处理.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubMultisets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (r+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        ctr = Counter(nums)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> value, count <span class="keyword">in</span> ctr.items():</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(r, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> value != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(j//value, count), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                        dp[j] += dp[j-k*value]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">            ans += dp[i] % mod_v</span><br><span class="line">        <span class="keyword">return</span> (ans*(ctr[<span class="number">0</span>]+<span class="number">1</span>)) % mod_v</span><br></pre></td></tr></table></figure>
<p>优化点在于前缀和,可以看到循环k的时候dp[j]是前缀和的形式, 所以我们可以直接反序遍历, 这样dp[j] += dp[j-value]就可以了. 但是这样又存在问题, 一旦超过了count * value, 我们其实并不能继续往后叠加, 因此需要把前面的值减掉. 当然我们也可以直接前向遍历求前缀, 后向遍历减掉多余前缀(O(n)空间换O(n)时间).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubMultisets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> l &gt; total:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">min</span>(total, r)</span><br><span class="line">        ctr = Counter(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (r+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = ctr[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> value, count <span class="keyword">in</span> ctr.items():</span><br><span class="line">            s = <span class="built_in">min</span>(r, s+count * value)</span><br><span class="line">            new_dp = dp.copy()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(value,s+<span class="number">1</span>):</span><br><span class="line">                new_dp[j] += new_dp[j-value] % mod_v</span><br><span class="line">                <span class="keyword">if</span> j &gt;= value * (count + <span class="number">1</span>):</span><br><span class="line">                    new_dp[j] -= dp[j-value*(count+<span class="number">1</span>)]</span><br><span class="line">            dp = new_dp</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">            ans += dp[i] % mod_v</span><br><span class="line">        <span class="keyword">return</span> ans % mod_v</span><br></pre></td></tr></table></figure>
<h2 id="分组背包">分组背包</h2>
<h3 id="掷骰子等于目标和的方法数">1155. 掷骰子等于目标和的方法数</h3>
<p>这里有 <code>n</code> 个一样的骰子，每个骰子上都有 <code>k</code> 个面，分别标号为 <code>1</code> 到 <code>k</code> 。</p>
<p>给定三个整数 <code>n</code>、<code>k</code> 和 <code>target</code>，请返回投掷骰子的所有可能得到的结果（共有 <code>kn</code> 种方式），使得骰子面朝上的数字总和等于 <code>target</code>。</p>
<p>由于答案可能很大，你需要对 <code>109 + 7</code> <strong>取模</strong>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>n = 1, k = 6, target = 3<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong>你掷了一个有 6 个面的骰子。<br />
得到总和为 3 的结果的方式只有一种。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>n = 2, k = 6, target = 7<br />
<strong>输出：</strong>6<br />
<strong>解释：</strong>你掷了两个骰子，每个骰子有 6 个面。<br />
有 6 种方式得到总和为 7 的结果: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>n = 30, k = 30, target = 500<br />
<strong>输出：</strong>222616187<br />
<strong>解释：</strong>返回的结果必须对 109 + 7 取模。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n, k &lt;= 30</code></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/submissions/549682773/">https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/submissions/549682773/</a></p>
<p>基础的背包版本, 每一个新骰子都有前k个状态决定, 我们可以用一个tmp记录所有状态, 倒序求和即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRollsToTarget</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>((i+<span class="number">1</span>)*k,target), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= v:</span><br><span class="line">                        tmp += dp[j-v] % mod_v</span><br><span class="line">                tmp %= mod_v</span><br><span class="line">                dp[j] = tmp</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] % mod_v</span><br></pre></td></tr></table></figure>
<p>注意到其实dp是个prefix sum的形式, 所以可以有前缀和优化. 同样, 可以多开个n空间换一遍遍历, 也可以正反遍历节约n空间.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRollsToTarget</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            prefix = <span class="number">0</span></span><br><span class="line">            max_ = <span class="built_in">min</span>((i+<span class="number">1</span>) * k, target)</span><br><span class="line">            prev = dp.copy()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(max_+<span class="number">1</span>):</span><br><span class="line">                dp[j], prefix = prefix, (prefix+dp[j]) % mod_v</span><br><span class="line">                <span class="keyword">if</span> j &gt;= k+<span class="number">1</span>:</span><br><span class="line">                    dp[j] -= prev[j-k-<span class="number">1</span>]</span><br><span class="line">                    prefix -= prev[j-k-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] % mod_v</span><br></pre></td></tr></table></figure>
<h3 id="最小化目标值与所选元素的差">1981. 最小化目标值与所选元素的差</h3>
<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> 和一个整数 <code>target</code> 。</p>
<p>从矩阵的 <strong>每一行</strong> 中选择一个整数，你的目标是 <strong>最小化</strong> 所有选中元素之 <strong>和</strong> 与目标值 <code>target</code> 的 <strong>绝对差</strong> 。</p>
<p>返回 <strong>最小的绝对差</strong> 。</p>
<p><code>a</code> 和 <code>b</code> 两数字的 <strong>绝对差</strong> 是 <code>a - b</code> 的绝对值。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/08/03/matrix1.png" /></p>
<p><strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>一种可能的最优选择方案是：<br />
- 第一行选出 1<br />
- 第二行选出 5<br />
- 第三行选出 7<br />
所选元素的和是 13 ，等于目标值，所以绝对差是 0 。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png" /></p>
<p><strong>输入：</strong>mat = [[1],[2],[3]], target = 100<br />
<strong>输出：</strong>94<br />
<strong>解释：</strong>唯一一种选择方案是：<br />
- 第一行选出 1<br />
- 第二行选出 2<br />
- 第三行选出 3<br />
所选元素的和是 6 ，绝对差是 94 。</p>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png" /></p>
<p><strong>输入：</strong>mat = [[1,2,9,8,7]], target = 6<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong>最优的选择方案是选出第一行的 7 。<br />
绝对差是 1 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 70</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 70</code></li>
<li><code>1 &lt;= target &lt;= 800</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/description/">https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/description/</a></p>
<p>最开始dp, 因为边界不清晰开的5000的数组, 导致TLE; 后面想到直接bfs一遍也可以, AC但是性能很差; 再后面想到加上某个值这种可以直接用bitmap来做, 击败几乎100%.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimizeTheDifference</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> mat[<span class="number">0</span>]:</span><br><span class="line">            curr |= (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> mat[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> row:</span><br><span class="line">                curr |= (prev&lt;&lt;element)</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5000</span>):</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;&gt; i) &amp; <span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(i-target))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="从栈中取出-k-个硬币的最大面值和">2218. 从栈中取出 K 个硬币的最大面值和</h3>
<p>一张桌子上总共有 <code>n</code> 个硬币 <strong>栈</strong> 。每个栈有 <strong>正整数</strong> 个带面值的硬币。</p>
<p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong> 取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p>
<p>给你一个列表 <code>piles</code> ，其中 <code>piles[i]</code> 是一个整数数组，分别表示第 <code>i</code> 个栈里 <strong>从顶到底</strong> 的硬币面值。同时给你一个正整数 <code>k</code> ，请你返回在 <strong>恰好</strong> 进行 <code>k</code> 次操作的前提下，你钱包里硬币面值之和 <strong>最大为多少</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/09/e1.png" /></p>
<p><strong>输入：</strong>piles = [[1,100,3],[7,8,9]], k = 2<br />
<strong>输出：</strong>101<br />
<strong>解释：</strong><br />
上图展示了几种选择 k 个硬币的不同方法。<br />
我们可以得到的最大面值为 101 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7<br />
<strong>输出：</strong>706<br />
<strong>解释：</strong><br />
如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == piles.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= piles[i][j] &lt;= 105</code></li>
<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/description/">https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/description/</a></p>
<p>说实话没写出来, 一开始写的4参数记忆化搜索, 爆内存, 优化到三参数记忆化搜索, 还是爆内存.</p>
<p>AC代码是正常dp, 一维表column, 二维表k值, 数值表大小. 可以压缩到一维. 正常AC就是2000ms, 压缩一维之后16MB内存. dfs的话双参数还是能AC的, 只是6000ms+200MB.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValueOfCoins</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (k+<span class="number">1</span>)</span><br><span class="line">        sum_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> pile <span class="keyword">in</span> piles:</span><br><span class="line">            n = <span class="built_in">len</span>(pile)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                pile[i] += pile[i-<span class="number">1</span>]</span><br><span class="line">            sum_n = <span class="built_in">min</span>(k, sum_n+n)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_n,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], <span class="built_in">max</span>(dp[j-w-<span class="number">1</span>]+pile[w] <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(n,j))))</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="经典线性dp">经典线性dp</h1>
<h2 id="lcs最长公共子序列">LCS(最长公共子序列)</h2>
<h3 id="最长公共子序列">1143. 最长公共子序列</h3>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>text1 = "abcde", text2 = "ace"<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>最长公共子序列是 "ace" ，它的长度为 3 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>text1 = "abc", text2 = "abc"<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>最长公共子序列是 "abc" ，它的长度为 3 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>text1 = "abc", text2 = "def"<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br />
</li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p>
<p>写起来比较简单, 不过多注意几个点.</p>
<ol type="1">
<li>字符相等的时候我们只用dp[i][j]=dp[i-1][j-1] + 1即可<br />
</li>
<li>不等的时候我们直接dp[i][j] = max(dp[i-1][j], dp[i][j-1])</li>
</ol>
<p>有上面的基础, 写出一个一维dp还是很简单的.</p>
<p>不过这里还可以优化, 我们可以用一个prev来记录左上角元素, 然后单数组即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(text1)</span><br><span class="line">        n = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            prev = dp[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j-<span class="number">1</span>], dp[j])</span><br><span class="line">                prev = tmp</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="两个字符串的删除操作">583. 两个字符串的删除操作</h3>
<p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和  <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入:</strong> word1 = "sea", word2 = "eat"<br />
<strong>输出:</strong> 2<br />
<strong>解释:</strong> 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"</p>
<p><strong>示例  2:</strong></p>
<p><strong>输入：</strong>word1 = "leetcode", word2 = "etco"<br />
<strong>输出：</strong>4</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">https://leetcode.cn/problems/delete-operation-for-two-strings/description/</a></p>
<p>两种思路, 一种是求LCS, 然后长度减掉就行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(word1)</span><br><span class="line">        n = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            prev = dp[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-<span class="number">1</span>])</span><br><span class="line">                prev = tmp</span><br><span class="line">        <span class="keyword">return</span> m+n-<span class="number">2</span>*dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>或者直接按删除来做, 相等的时候dp[i][j] = dp[i-1][j-1], 否则dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + 1.</p>
<p>然后压缩为度, 最后就是初始化的时候注意dp[0]要赋值i.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(word1)</span><br><span class="line">        n = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = <span class="built_in">list</span>(<span class="built_in">range</span>(n+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            prev = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j],dp[j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                prev = tmp</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="两个字符串的最小ascii删除和">712. 两个字符串的最小ASCII删除和</h3>
<p>给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 <em>使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> s1 = "sea", s2 = "eat"<br />
<strong>输出:</strong> 231<br />
<strong>解释:</strong> 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。<br />
在 "eat" 中删除 "t" 并将 116 加入总和。<br />
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> s1 = "delete", s2 = "leet"<br />
<strong>输出:</strong> 403<br />
<strong>解释:</strong> 在 "delete" 中删除 "dee" 字符串变成 "let"，<br />
将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。<br />
结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。<br />
如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= s1.length, s2.length &lt;= 1000</code></li>
<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/">https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/</a></p>
<p>LCS做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumDeleteSum</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(s1)</span><br><span class="line">        n = <span class="built_in">len</span>(s2)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            prev = dp[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev + <span class="built_in">ord</span>(s1[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j-<span class="number">1</span>],dp[j])</span><br><span class="line">                prev = tmp</span><br><span class="line">        </span><br><span class="line">        sum_1 = <span class="built_in">sum</span>(<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s1)</span><br><span class="line">        sum_2 = <span class="built_in">sum</span>(<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s2)</span><br><span class="line">        <span class="keyword">return</span> sum_1 + sum_2 - <span class="number">2</span>*dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>正面直接撕删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumDeleteSum</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(s1)</span><br><span class="line">        n = <span class="built_in">len</span>(s2)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+<span class="built_in">ord</span>(s2[i-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            prev = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + <span class="built_in">ord</span>(s1[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j-<span class="number">1</span>]+<span class="built_in">ord</span>(s2[j-<span class="number">1</span>]),dp[j]+<span class="built_in">ord</span>(s1[i-<span class="number">1</span>]))</span><br><span class="line">                prev = tmp</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离">72. 编辑距离</h3>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符<br />
</li>
<li>删除一个字符<br />
</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>word1 = "horse", word2 = "ros"<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong><br />
horse -&gt; rorse (将 'h' 替换为 'r')<br />
rorse -&gt; rose (删除 'r')<br />
rose -&gt; ros (删除 'e')</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>word1 = "intention", word2 = "execution"<br />
<strong>输出：</strong>5<br />
<strong>解释：</strong><br />
intention -&gt; inention (删除 't')<br />
inention -&gt; enention (将 'i' 替换为 'e')<br />
enention -&gt; exention (将 'n' 替换为 'x')<br />
exention -&gt; exection (将 'n' 替换为 'c')<br />
exection -&gt; execution (插入 'u')</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p>
<p>状态转移理解起来会麻烦一点, dp[i][j]往后转移的话, 删除text1字符就相当于dp[i-1][j],删text2就是dp[i][j-1],替换掉就是dp[i-1][j-1].</p>
<p>一开始二维dp写的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(word1)</span><br><span class="line">        n = <span class="built_in">len</span>(word2)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>压缩到一维</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(word1)</span><br><span class="line">        n = <span class="built_in">len</span>(word2)</span><br><span class="line"></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            prev = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j-<span class="number">1</span>], prev, tmp)+<span class="number">1</span></span><br><span class="line">                prev = tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="交错字符串">97. 交错字符串</h3>
<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干<strong>非空</strong>子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code><br />
</li>
<li><code>t = t1 + t2 + ... + tm</code><br />
</li>
<li><code>|n - m| &lt;= 1</code><br />
</li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg" /></p>
<p><strong>输入：</strong>s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"<br />
<strong>输出：</strong>true</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"<br />
<strong>输出：</strong>false</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>s1 = "", s2 = "", s3 = ""<br />
<strong>输出：</strong>true</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>
<li><code>0 &lt;= s3.length &lt;= 200</code></li>
<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>
</ul>
<p><strong>进阶：</strong>您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/description/">https://leetcode.cn/problems/interleaving-string/description/</a></p>
<p>记忆化搜索会速度快一些,但是内存占用高</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(s1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(s2)</span><br><span class="line">        n3 = <span class="built_in">len</span>(s3)</span><br><span class="line">        <span class="keyword">if</span> n3 != n1 + n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">l,r</span>):</span><br><span class="line">            <span class="keyword">while</span> l &lt; n1 <span class="keyword">and</span> r &lt; n2:</span><br><span class="line">                char1, char2, char3 = s1[l],s2[r],s3[l+r]</span><br><span class="line">                <span class="keyword">if</span> char3 == char1 <span class="keyword">and</span> char3 != char2:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> char3 == char2 <span class="keyword">and</span> char3 != char1:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> char3 != char1 <span class="keyword">and</span> char3 != char2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> char3 == char1 <span class="keyword">and</span> char3 == char2:</span><br><span class="line">                    left = dfs(l+<span class="number">1</span>,r) <span class="keyword">if</span> l+<span class="number">1</span> &lt; n1 <span class="keyword">else</span> s3[l+r+<span class="number">1</span>:] == s2[r:]</span><br><span class="line">                    <span class="keyword">if</span> left:</span><br><span class="line">                        <span class="keyword">return</span> left</span><br><span class="line">                    right = dfs(l, r+<span class="number">1</span>) <span class="keyword">if</span> r+<span class="number">1</span> &lt; n2 <span class="keyword">else</span> s3[l+r+<span class="number">1</span>:] == s1[l:]</span><br><span class="line">                    <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">if</span> l == n1:</span><br><span class="line">                <span class="keyword">return</span> s3[l+r:] == s2[r:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> s3[l+r:] == s1[l:]</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>dp的话则是可以内存优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(s1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(s2)</span><br><span class="line">        n3 = <span class="built_in">len</span>(s3)</span><br><span class="line">        <span class="keyword">if</span> n3 != n1 + n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (n2+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s2[i-<span class="number">1</span>] == s3[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>] = (s1[i-<span class="number">1</span>] == s3[i-<span class="number">1</span>] <span class="keyword">and</span> dp[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                dp[j] &amp;=  (s3[i+j-<span class="number">1</span>] == s1[i-<span class="number">1</span>])</span><br><span class="line">                dp[j] |= (dp[j-<span class="number">1</span>] <span class="keyword">and</span> s3[i+j-<span class="number">1</span>] == s2[j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="不同的子序列">115. 不同的子序列</h3>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 109 + 7 取模。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>s = "rabbbit", t = "rabbit"<br />
<code>**输出**</code><strong>：</strong><code>3</code><br />
<strong>解释：</strong><br />
如下所示, 有 3 种可以从 s 中得到 <code>"rabbit" 的方案</code>。<br />
<code>**rabb**b**it**</code><br />
<code>**ra**b**bbit**</code><br />
<code>**rab**b**bit**</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>s = "babgbag", t = "bag"<br />
<code>**输出**</code><strong>：</strong><code>5</code><br />
<strong>解释：</strong><br />
如下所示, 有 5 种可以从 s 中得到 <code>"bag" 的方案</code>。<br />
<code>**ba**b**g**bag</code><br />
<code>**ba**bgba**g**</code><br />
<code>**b**abgb**ag**</code><br />
<code>ba**b**gb**ag**</code><br />
<code>babg**bag**</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/description/">https://leetcode.cn/problems/distinct-subsequences/description/</a></p>
<p>记忆化搜索直接秒双100, 需要注意剪枝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,j</span>):</span><br><span class="line">            first = <span class="number">0</span></span><br><span class="line">            second = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j == n2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == n1 <span class="keyword">or</span> n1-i &lt; n2-j:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> s[i] != t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n2 <span class="keyword">and</span> i &lt; n1:</span><br><span class="line">                first = dfs(i+<span class="number">1</span>,j+<span class="number">1</span>) % mod_v</span><br><span class="line">            <span class="keyword">if</span> i &lt; n1:</span><br><span class="line">                second = dfs(i+<span class="number">1</span>,j) % mod_v</span><br><span class="line">            <span class="keyword">return</span> (first+second) % mod_v</span><br><span class="line">        ans = dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>递推写法会复杂一些, 这里我开的数组是t的长度.</p>
<p>那么字符匹配到了的话可以匹配也可以不匹配, 那么递推:</p>
<ol type="1">
<li>字符相同,可以匹配也可以跳过: dp[i][j] = dp[i-1][j-1] + dp[i-1][j].<br />
</li>
<li>字符不同,只可以跳过: dp[i][j] = dp[i-1][j].</li>
</ol>
<p>其中dp[i-1][j-1]表示这个字符匹配到了,取回上个状态; 而dp[i-1][j]表示s这个字符被吞,j没有匹配到. 如果二维难理解的话可以看一维, 即使i变化了, 我们还是dp[j]=dp[j], 说明i的变化没有用, 即被丢弃.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n2+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            pre = dp[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>] == t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = (dp[j] + pre) % mod_v</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = dp[j] % mod_v</span><br><span class="line">                pre = tmp</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] % mod_v</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%89%8D%E7%8A%B6%E6%80%81%E5%8A%A0%E5%88%B0%E5%90%8E%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">爬楼梯(前状态加到后状态)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-2466.-%E7%BB%9F%E8%AE%A1%E6%9E%84%E9%80%A0%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础: 2466. 统计构造好字符串的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-2266.-%E7%BB%9F%E8%AE%A1%E6%89%93%E5%AD%97%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">进阶: 2266. 统计打字方案数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.</span> <span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础: 198. 打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-3186.-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">进阶: 3186. 施咒的最大总伤害</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">基础: 53. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B61-918.-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">进阶1: 918. 环形子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B62-1191.-k-%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">进阶2: 1191. K 次串联后最大子数组之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.3.4.</span> <span class="toc-text">1186. 删除一次得到子数组最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%89%A9%E5%B1%95-152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">思路扩展: 152. 乘积最大子数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BCdp"><span class="toc-number">1.4.</span> <span class="toc-text">网格dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%82%B9%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础点的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">2684. 矩阵中移动的最大次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.4.3.</span> <span class="toc-text">2304. 网格中的最小路径代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%9E%E8%B4%9F%E7%A7%AF"><span class="toc-number">1.4.5.</span> <span class="toc-text">1594. 矩阵的最大非负积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.6.</span> <span class="toc-text">1301. 最大得分的路径数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%AB-k-%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.7.</span> <span class="toc-text">2435. 矩阵中和能被 K 整除的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="toc-number">1.4.8.</span> <span class="toc-text">174. 地下城游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.9.</span> <span class="toc-text">329. 矩阵中的最长递增路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.10.</span> <span class="toc-text">2328. 网格图中递增路径的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.11.</span> <span class="toc-text">2267. 检查是否有合法括号字符串路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">1.4.12.</span> <span class="toc-text">1937. 扣分后的最大得分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83-ii"><span class="toc-number">1.4.13.</span> <span class="toc-text">1463. 摘樱桃 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83"><span class="toc-number">1.4.14.</span> <span class="toc-text">741. 摘樱桃</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">背包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85-1"><span class="toc-number">2.1.</span> <span class="toc-text">0-1背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">2915. 和为目标值的最长子序列的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">494. 目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%88%90%E5%B9%82%E7%9A%84%E5%92%8C%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">2787. 将一个数字表示成幂的和的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-i"><span class="toc-number">2.1.5.</span> <span class="toc-text">3180. 执行操作可获得的最大总奖励 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">2.1.6.</span> <span class="toc-text">474. 一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii"><span class="toc-number">2.1.7.</span> <span class="toc-text">1049. 最后一块石头的重量 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC"><span class="toc-number">2.1.8.</span> <span class="toc-text">1774. 最接近目标价格的甜点成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%88%E5%88%A9%E8%AE%A1%E5%88%92"><span class="toc-number">2.1.9.</span> <span class="toc-text">879. 盈利计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E8%83%BD%E9%87%8F%E5%92%8C"><span class="toc-number">2.1.10.</span> <span class="toc-text">3082. 求出所有子序列的能量和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E7%9A%84%E5%B9%BF%E5%91%8A%E7%89%8C"><span class="toc-number">2.1.11.</span> <span class="toc-text">956. 最高的广告牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%88%86%E5%8C%BA%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.1.12.</span> <span class="toc-text">2518. 好分区的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%A2%99%E5%A3%81%E5%88%B7%E6%B2%B9%E6%BC%86"><span class="toc-number">2.1.13.</span> <span class="toc-text">2742. 给墙壁刷油漆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lcp-47.-%E5%85%A5%E5%9C%BA%E5%AE%89%E6%A3%80"><span class="toc-number">2.1.14.</span> <span class="toc-text">LCP 47. 入场安检</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">2.2.</span> <span class="toc-text">完全背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii"><span class="toc-number">2.2.2.</span> <span class="toc-text">518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">279. 完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-number">2.2.4.</span> <span class="toc-text">1449. 数位成本和为目标值的最大数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.</span> <span class="toc-text">多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%88%86%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2585. 获得分数的方法数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">2902. 和带限制的子多重集合的数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-number">2.4.</span> <span class="toc-text">分组背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%92%8C%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">1155. 掷骰子等于目标和的方法数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%8E%E6%89%80%E9%80%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%B7%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">1981. 最小化目标值与所选元素的差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%A0%88%E4%B8%AD%E5%8F%96%E5%87%BA-k-%E4%B8%AA%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E5%80%BC%E5%92%8C"><span class="toc-number">2.4.3.</span> <span class="toc-text">2218. 从栈中取出 K 个硬币的最大面值和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BA%BF%E6%80%A7dp"><span class="toc-number">3.</span> <span class="toc-text">经典线性dp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lcs%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">LCS(最长公共子序列)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">1143. 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">583. 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C"><span class="toc-number">3.1.3.</span> <span class="toc-text">712. 两个字符串的最小ASCII删除和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">3.1.4.</span> <span class="toc-text">72. 编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.1.5.</span> <span class="toc-text">97. 交错字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.6.</span> <span class="toc-text">115. 不同的子序列</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=DSA-动态规划"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=DSA-动态规划"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DSA-动态规划&body=Check out this article: http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=DSA-动态规划"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=DSA-动态规划&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=DSA-动态规划"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    blacsheep
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
