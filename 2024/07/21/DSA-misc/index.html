<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="近期主要在写dp多一些, 不过也碰到一些杂项相关, 主要针对近期看到的以前没用过的东西, 也包括一些图论相关. 简单记录一下相关模版, 方便后续看到类似的题目好处理. 8月18双周赛 100401. 放三个车的价值之和最大 II 给你一个 m x n 的二维整数数组 board ，它表示一个国际象棋棋盘，其中 board[i][j] 表示格子 (i, j) 的 价值 。 处于 同一行 或者 同一列">
<meta property="og:type" content="article">
<meta property="og:title" content="DSA-misc">
<meta property="og:url" content="http://example.com/2024/07/21/DSA-misc/index.html">
<meta property="og:site_name" content="blacsheep&#39;s blog">
<meta property="og:description" content="近期主要在写dp多一些, 不过也碰到一些杂项相关, 主要针对近期看到的以前没用过的东西, 也包括一些图论相关. 简单记录一下相关模版, 方便后续看到类似的题目好处理. 8月18双周赛 100401. 放三个车的价值之和最大 II 给你一个 m x n 的二维整数数组 board ，它表示一个国际象棋棋盘，其中 board[i][j] 表示格子 (i, j) 的 价值 。 处于 同一行 或者 同一列">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/08/08/rooks2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/05/26/tree1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/03/screenshot-2024-06-03-193552.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/08/08/rob.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/05/18/example2circle1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/05/18/example1circle.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/05/18/example0circle.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/12/24/land1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/12/24/land2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/11/08/example11.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/11/08/example22.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/03/09/example1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2024/03/09/example2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/09/29/e1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/09/29/e2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/09/29/eg2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png">
<meta property="article:published_time" content="2024-07-21T11:21:08.000Z">
<meta property="article:modified_time" content="2024-08-18T09:18:08.622Z">
<meta property="article:author" content="blacsheep">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2024/08/08/rooks2.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>DSA-misc</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/07/19/DSA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/07/21/DSA-misc/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/07/21/DSA-misc/&text=DSA-misc"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/07/21/DSA-misc/&is_video=false&description=DSA-misc"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DSA-misc&body=Check out this article: http://example.com/2024/07/21/DSA-misc/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/07/21/DSA-misc/&name=DSA-misc&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/07/21/DSA-misc/&t=DSA-misc"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8818%E5%8F%8C%E5%91%A8%E8%B5%9B"><span class="toc-number">1.</span> <span class="toc-text">8月18双周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E4%B8%89%E4%B8%AA%E8%BD%A6%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7-ii"><span class="toc-number">1.1.</span> <span class="toc-text">100401. 放三个车的价值之和最大 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8818%E5%91%A8%E8%B5%9B"><span class="toc-number">2.</span> <span class="toc-text">8月18周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D-k-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">100409. 找出最大的 N 位 K 回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%BB%A1%E8%B6%B3-k-%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E9%87%8F-ii"><span class="toc-number">2.2.</span> <span class="toc-text">100404. 统计满足 K 约束的子字符串数量 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8811%E5%91%A8%E8%B5%9B"><span class="toc-number">3.</span> <span class="toc-text">8月11周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">3.1.</span> <span class="toc-text">100354. 统计好节点的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%95%B0%E7%BB%84%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE-ii"><span class="toc-number">3.2.</span> <span class="toc-text">100396. 单调数组对的数目 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%884%E5%91%A8%E8%B5%9B"><span class="toc-number">4.</span> <span class="toc-text">8月4周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB-i"><span class="toc-number">4.1.</span> <span class="toc-text">100379. 新增道路查询后的最短距离 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB-ii"><span class="toc-number">4.2.</span> <span class="toc-text">100376. 新增道路查询后的最短距离 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E7%BB%84-iii"><span class="toc-number">4.3.</span> <span class="toc-text">3245. 交替组 III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8828%E5%91%A8%E8%B5%9B"><span class="toc-number">5.</span> <span class="toc-text">7月28周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%8D%E6%98%AF%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">100371. 统计不是特殊数字的数字数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1-1-%E6%98%BE%E8%91%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">100348. 统计 1 显著的字符串的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%92%E8%90%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE"><span class="toc-number">5.3.</span> <span class="toc-text">100347. 判断矩形的两个角落是否可达</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">1395. 统计作战单位数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%89%E8%90%BD%E7%9A%84%E6%96%B9%E5%9D%97"><span class="toc-number">7.1.</span> <span class="toc-text">699. 掉落的方块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">差分数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E8%BD%A6"><span class="toc-number">8.1.</span> <span class="toc-text">1094. 拼车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">100329. 使数组等于目标数组所需的最少操作次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">9.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6"><span class="toc-number">9.1.</span> <span class="toc-text">721. 账户合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number"></span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tarjan"><span class="toc-number">1.</span> <span class="toc-text">tarjan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E9%99%86%E5%9C%B0%E5%88%86%E7%A6%BB%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1568. 使陆地分离的最少天数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.</span> <span class="toc-text">2392. 给定条件下构造矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">floyd算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%88%86%E9%83%A8%E7%9A%84%E5%8F%AF%E8%A1%8C%E9%9B%86%E5%90%88%E6%95%B0%E7%9B%AE"><span class="toc-number">3.1.</span> <span class="toc-text">2959. 关闭分部的可行集合数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82"><span class="toc-number">3.2.</span> <span class="toc-text">1334. 阈值距离内邻居最少的城市</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%B6%88%E5%A4%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4"><span class="toc-number">4.1.</span> <span class="toc-text">3112. 访问消失节点的最少时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%9F%AD%E6%97%B6%E9%97%B4"><span class="toc-number">4.2.</span> <span class="toc-text">2045. 到达目的地的第二短时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bitset"><span class="toc-number"></span> <span class="toc-text">bitset</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%81%8D%E5%8E%86%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">简单遍历题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%88%86%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B8%E5%BC%B9"><span class="toc-number">1.1.</span> <span class="toc-text">2101. 引爆最多的炸弹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">dp题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-ii"><span class="toc-number">2.1.</span> <span class="toc-text">3181. 执行操作可获得的最大总奖励 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="toc-number">3.</span> <span class="toc-text">数位dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%AB%E8%BF%9E%E7%BB%AD1%E7%9A%84%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">600. 不含连续1的非负整数</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        DSA-misc
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">blacsheep</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-07-21T11:21:08.000Z" class="dt-published" itemprop="datePublished">2024-07-21</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>近期主要在写dp多一些, 不过也碰到一些杂项相关, 主要针对近期看到的以前没用过的东西, 也包括一些图论相关.</p>
<p>简单记录一下相关模版, 方便后续看到类似的题目好处理.</p>
<h2 id="月18双周赛">8月18双周赛</h2>
<h3 id="放三个车的价值之和最大-ii">100401. 放三个车的价值之和最大 II</h3>
<p>给你一个 <code>m x n</code> 的二维整数数组 <code>board</code> ，它表示一个国际象棋棋盘，其中 <code>board[i][j]</code> 表示格子 <code>(i, j)</code> 的 <strong>价值</strong> 。</p>
<p>处于 <strong>同一行</strong> 或者 <strong>同一列</strong> 车会互相 <strong>攻击</strong> 。你需要在棋盘上放三个车，确保它们两两之间都 <strong>无法互相攻击</strong> 。</p>
<p>请你返回满足上述条件下，三个车所在格子 <strong>值</strong> 之和 <strong>最大</strong> 为多少。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]</p>
<p><strong>输出：</strong>4</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/08/08/rooks2.png" /></p>
<p>我们可以将车分别放在格子 <code>(0, 2)</code> ，<code>(1, 3)</code> 和 <code>(2, 1)</code> 处，价值之和为 <code>1 + 1 + 2 = 4</code> 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>board = [[1,2,3],[4,5,6],[7,8,9]]</p>
<p><strong>输出：</strong>15</p>
<p><strong>解释：</strong></p>
<p>我们可以将车分别放在格子 <code>(0, 0)</code> ，<code>(1, 1)</code> 和 <code>(2, 2)</code> 处，价值之和为 <code>1 + 5 + 9 = 15</code> 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>board = [[1,1,1],[1,1,1],[1,1,1]]</p>
<p><strong>输出：</strong>3</p>
<p><strong>解释：</strong></p>
<p>我们可以将车分别放在格子 <code>(0, 2)</code> ，<code>(1, 1)</code> 和 <code>(2, 0)</code> 处，价值之和为 <code>1 + 1 + 1 = 3</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= m == board.length &lt;= 500</code></li>
<li><code>3 &lt;= n == board[i].length &lt;= 500</code></li>
<li><code>-109 &lt;= board[i][j] &lt;= 109</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/description/">https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/description/</a></p>
<p>一开始是记忆化搜索, 爆内存了, 823/842</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumValueSum</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        candidate = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> board:</span><br><span class="line">            q = []</span><br><span class="line">            <span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                heapq.heappush(q, (value, idx))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(q) == <span class="number">4</span>:</span><br><span class="line">                    heapq.heappop(q)</span><br><span class="line">            candidate.append(q)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">visited, i, sum_</span>):</span><br><span class="line">            <span class="keyword">if</span> visited.bit_count() == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> sum_</span><br><span class="line">            <span class="keyword">if</span> i == m:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            res = dfs(visited, i+<span class="number">1</span>, sum_)</span><br><span class="line">            <span class="keyword">for</span> cand <span class="keyword">in</span> candidate[i]:</span><br><span class="line">                idx = cand[<span class="number">1</span>]</span><br><span class="line">                bin_ = <span class="number">1</span> &lt;&lt; idx</span><br><span class="line">                <span class="keyword">if</span> (bin_) &amp; visited == <span class="number">0</span>:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dfs(visited | bin_, i+<span class="number">1</span>, sum_+board[i][idx]))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>正解两种, 一种是枚举, 最后想到了但是没写出来.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumValueSum</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        all_nums = [(board[i][j], (i, j)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        all_nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        tot = <span class="number">3</span> * <span class="built_in">max</span>(n, m)</span><br><span class="line"></span><br><span class="line">        ans = -<span class="number">10</span>**<span class="number">18</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            ai, aj = all_nums[start][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">1</span>, tot):</span><br><span class="line">                bi, bj = all_nums[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, tot):</span><br><span class="line">                    ci, cj = all_nums[j][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> ai != bi <span class="keyword">and</span> bi != ci <span class="keyword">and</span> ai != ci <span class="keyword">and</span> aj != bj <span class="keyword">and</span> bj != cj <span class="keyword">and</span> aj != cj:</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, all_nums[start][<span class="number">0</span>] +</span><br><span class="line">                                  all_nums[i][<span class="number">0</span>] + all_nums[j][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>非常暴力的做法, 全元素sort一下, 然后最大范围用三倍最大值做限制, 第一个元素最坏可能与二三元素共行共列共4次, 那么我们遍历5次一定有最大值. 第二元素在第一元素后面, 第三元素在第二元素后面, 每次对x和y做判定.</p>
<p>另一种是前行拆分(灵神的做法), 我们锁定一个中间元素, 元素这行之前的行找到三个最大值, 这行之后的行找三个最大值, 然后枚举所有中间元素, 对每个中间元素枚举最大值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/solutions/2884186/qian-hou-zhui-fen-jie-pythonjavacgo-by-e-gc48</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumValueSum</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">row: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> j, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> x &gt; p[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> p[<span class="number">0</span>][<span class="number">1</span>] != j:  <span class="comment"># 如果相等，仅更新最大</span></span><br><span class="line">                        <span class="keyword">if</span> p[<span class="number">1</span>][<span class="number">1</span>] != j:  <span class="comment"># 如果相等，仅更新最大和次大</span></span><br><span class="line">                            p[<span class="number">2</span>] = p[<span class="number">1</span>]</span><br><span class="line">                        p[<span class="number">1</span>] = p[<span class="number">0</span>]</span><br><span class="line">                    p[<span class="number">0</span>] = (x, j)</span><br><span class="line">                <span class="keyword">elif</span> j != p[<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">and</span> x &gt; p[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> p[<span class="number">1</span>][<span class="number">1</span>] != j:  <span class="comment"># 如果相等，仅更新次大</span></span><br><span class="line">                        p[<span class="number">2</span>] = p[<span class="number">1</span>]</span><br><span class="line">                    p[<span class="number">1</span>] = (x, j)</span><br><span class="line">                <span class="keyword">elif</span> j != p[<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">and</span> j != p[<span class="number">1</span>][<span class="number">1</span>] <span class="keyword">and</span> x &gt; p[<span class="number">2</span>][<span class="number">0</span>]:</span><br><span class="line">                    p[<span class="number">2</span>] = (x, j)</span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        suf = [<span class="literal">None</span>] * m</span><br><span class="line">        p = [(-inf, -<span class="number">1</span>)] * <span class="number">3</span>  <span class="comment"># 最大、次大、第三大</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            update(board[i])</span><br><span class="line">            suf[i] = p[:]</span><br><span class="line"></span><br><span class="line">        ans = -inf</span><br><span class="line">        p = [(-inf, -<span class="number">1</span>)] * <span class="number">3</span>  <span class="comment"># 重置，计算 pre</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(board[:-<span class="number">2</span>]):</span><br><span class="line">            update(row)</span><br><span class="line">            <span class="keyword">for</span> j2, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(board[i + <span class="number">1</span>]):  <span class="comment"># 第二个车</span></span><br><span class="line">                <span class="keyword">for</span> x, j1 <span class="keyword">in</span> p:  <span class="comment"># 第一个车</span></span><br><span class="line">                    <span class="keyword">for</span> z, j3 <span class="keyword">in</span> suf[i + <span class="number">2</span>]:  <span class="comment"># 第三个车</span></span><br><span class="line">                        <span class="keyword">if</span> j1 != j2 <span class="keyword">and</span> j1 != j3 <span class="keyword">and</span> j2 != j3:  <span class="comment"># 没有同列的车</span></span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, x + y + z)  <span class="comment"># 注：手动 if 更快</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="月18周赛">8月18周赛</h2>
<h3 id="找出最大的-n-位-k-回文数">100409. 找出最大的 N 位 K 回文数</h3>
<p>给你两个 <strong>正整数</strong> <code>n</code> 和 <code>k</code>。</p>
<p>如果整数 <code>x</code> 满足以下全部条件，则该整数是一个 <strong>k 回文数</strong>：</p>
<ul>
<li><code>x</code> 是一个回文数。<br />
</li>
<li><code>x</code> 可以被 <code>k</code> 整除。</li>
</ul>
<p>以字符串形式返回 <strong>最大的</strong>  <code>n</code> 位 <strong>k 回文数</strong>。</p>
<p><strong>注意</strong>，该整数 <strong>不</strong> 含前导零。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> n = 3, k = 5</p>
<p><strong>输出：</strong> "595"</p>
<p><strong>解释：</strong></p>
<p>595 是最大的 3 位 k 回文数。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> n = 1, k = 4</p>
<p><strong>输出：</strong> "8"</p>
<p><strong>解释：</strong></p>
<p>1 位 k 回文数只有 4 和 8。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> n = 5, k = 6</p>
<p><strong>输出：</strong> "89898"</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= k &lt;= 9</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-largest-palindrome-divisible-by-k/description/">https://leetcode.cn/problems/find-the-largest-palindrome-divisible-by-k/description/</a></p>
<p>这题有非常暴力的做法: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-largest-palindrome-divisible-by-k/solutions/2884497/zheng-chu-xing-zhi-yu-hui-wen-xing-zhi-j-erc2">整除性质与回文性质结合打表</a></p>
<p>k = 1,3,9 ，全位填9<br />
k = 2,4,8，分别填好首尾1,2,3位，由其整除性质，只能填8，中间任意填9<br />
k = 5, 首尾填5，其他填9<br />
k = 6 ，结合2和3的整除性质，如果n为奇数，首尾、中位填8，其他填9；如果n为偶数，首尾填8，中位填7，其他填9<br />
k = 7，常用结论7整除1001，可推得7整除999999，即999999XXX999999 % 7 = XXX % 7, 枚举n % 12即可</p>
<p>硬核打表, 双O(1), 说实话不太像个正常人能想出来的做法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPalindrome</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span> <span class="keyword">or</span> k == <span class="number">3</span> <span class="keyword">or</span> k == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * n</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;8&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;8&quot;</span> + <span class="string">&quot;9&quot;</span> * (n - <span class="number">2</span>) + <span class="string">&quot;8&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;8&quot;</span> * n</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;88&quot;</span> + <span class="string">&quot;9&quot;</span> * (n - <span class="number">4</span>) + <span class="string">&quot;88&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;5&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;5&quot;</span> + <span class="string">&quot;9&quot;</span> * (n - <span class="number">2</span>) + <span class="string">&quot;5&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;8&quot;</span> * n</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;888&quot;</span> + <span class="string">&quot;9&quot;</span> * (n - <span class="number">6</span>) + <span class="string">&quot;888&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;6&quot;</span> * n</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;8&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">1</span>) + <span class="string">&quot;8&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">1</span>) + <span class="string">&quot;8&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;8&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">2</span>) + <span class="string">&quot;7&quot;</span> + <span class="string">&quot;7&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">2</span>) + <span class="string">&quot;8&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">6</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * n</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span>) + <span class="string">&quot;7&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">1</span>) + <span class="string">&quot;77&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">1</span>) + <span class="string">&quot;959&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">2</span>) + <span class="string">&quot;9779&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">2</span>) + <span class="string">&quot;99799&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">3</span>) + <span class="string">&quot;9994999&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">4</span>) + <span class="string">&quot;99944999&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">4</span>) + <span class="string">&quot;999969999&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">5</span>) + <span class="string">&quot;9999449999&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">12</span> == <span class="number">11</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">5</span>) + <span class="string">&quot;99999499999&quot;</span> + <span class="string">&quot;9&quot;</span> * (n // <span class="number">2</span> - <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>灵神的做法更加常规一点, 我们直接对n开爆搜, 硬填完n//2 + 1个数字, 每个数字填双向, 可以直接O(1)算出增量, 同时结果里面保留一个模k的值, 这样可以多开一个记忆化功能, 一旦到某个位且取模之后无法到终点, 这个后面就不用再算. 关键思路是 <code>(a+b) % k = ((a%k) + (b%k)) % k</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPalindrome</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        pow10 = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            pow10[i] = pow10[i - <span class="number">1</span>] * <span class="number">10</span> % k</span><br><span class="line"></span><br><span class="line">        ans = [<span class="literal">None</span>] * n</span><br><span class="line">        m = (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        vis = [[<span class="literal">False</span>] * k <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> i == m:</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span></span><br><span class="line">            vis[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 贪心：从大到小枚举</span></span><br><span class="line">                <span class="keyword">if</span> n % <span class="number">2</span> <span class="keyword">and</span> i == m - <span class="number">1</span>:  <span class="comment"># 正中间</span></span><br><span class="line">                    j2 = (j + d * pow10[i]) % k</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j2 = (j + d * (pow10[i] + pow10[-<span class="number">1</span> - i])) % k</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> vis[i + <span class="number">1</span>][j2] <span class="keyword">and</span> dfs(i + <span class="number">1</span>, j2):</span><br><span class="line">                    ans[i] = ans[-<span class="number">1</span> - i] = <span class="built_in">str</span>(d)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure>
<h3 id="统计满足-k-约束的子字符串数量-ii">100404. 统计满足 K 约束的子字符串数量 II</h3>
<p>给你一个 <strong>二进制</strong> 字符串 <code>s</code> 和一个整数 <code>k</code>。</p>
<p>另给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。</p>
<p>如果一个 <strong>二进制字符串</strong> 满足以下任一条件，则认为该字符串满足 <strong>k 约束</strong>：</p>
<ul>
<li>字符串中 <code>0</code> 的数量最多为 <code>k</code>。<br />
</li>
<li>字符串中 <code>1</code> 的数量最多为 <code>k</code>。</li>
</ul>
<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 表示 <code>s[li..ri]</code> 中满足 <strong>k 约束</strong> 的子字符串的数量。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>s = "0001111", k = 2, queries = [[0,6]]</p>
<p><strong>输出：</strong>[26]</p>
<p><strong>解释：</strong></p>
<p>对于查询 <code>[0, 6]</code>， <code>s[0..6] = "0001111"</code> 的所有子字符串中，除 <code>s[0..5] = "000111"</code> 和 <code>s[0..6] = "0001111"</code> 外，其余子字符串都满足 k 约束。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>s = "010101", k = 1, queries = [[0,5],[1,4],[2,3]]</p>
<p><strong>输出：</strong>[15,9,3]</p>
<p><strong>解释：</strong></p>
<p><code>s</code> 的所有子字符串中，长度大于 3 的子字符串都不满足 k 约束。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 是 <code>'0'</code> 或 <code>'1'</code></li>
<li><code>1 &lt;= k &lt;= s.length</code></li>
<li><code>1 &lt;= queries.length &lt;= 105</code></li>
<li><code>queries[i] == [li, ri]</code></li>
<li><code>0 &lt;= li &lt;= ri &lt; s.length</code></li>
<li>所有查询互不相同</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/description/">https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/description/</a></p>
<p>超多知识点的一道题.</p>
<ol type="1">
<li>首先我们用贪心的思路, 注意到一旦某个最长串满足条件, 其所有字串都满足题意.<br />
</li>
<li>由此联想到我们可以找到一个left数组, left[r]表示以r为结尾的满足题意的最长串, 其l可能的最小值.<br />
</li>
<li>这个left数组我们可以用滑动窗口的方法来求出来.<br />
</li>
<li>那么由此假如我们有一个从l到r的串, 我们的答案为 <code>$ \sum_&#123;i=l&#125;^&#123;r&#125; (i - max(left[i],l) + 1) $</code>.<br />
</li>
<li>在此基础之上, 我们提取出i和1, 前面是个等差数列求和,O(1)计算时间, 后面为max(left[i],l)的求和.<br />
</li>
<li>由此我们可以预先处理好left的前缀和, 然后分类讨论来获取这个 negative部分.<br />
</li>
<li>又注意到left数组其实是个递增的数组, 所以我们可以二分来找到negative部分的分界点.<br />
</li>
<li>两者相减, 加入ans即可.</li>
</ol>
<p>所以这题的考点有: 贪心, 滑动窗口, 一些简单的数学拆分, 前缀和, 二分, 很好的一道题.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countKConstraintSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span>, queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left = []</span><br><span class="line">        count = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            count[<span class="built_in">ord</span>(i)&amp;<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> count[<span class="number">0</span>] &gt; k <span class="keyword">and</span> count[<span class="number">1</span>] &gt; k:</span><br><span class="line">                count[<span class="built_in">ord</span>(s[l])&amp;<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            left.append(l)</span><br><span class="line"></span><br><span class="line">        prefix_left = <span class="built_in">list</span>(accumulate(left))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> l, r <span class="keyword">in</span> queries:</span><br><span class="line">            base = (r + l + <span class="number">2</span>) * (r-l+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            idx = bisect.bisect_left(left, l+<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># left[idx] &lt; l</span></span><br><span class="line">            <span class="comment"># left[idx+1] &gt; l</span></span><br><span class="line">            <span class="keyword">if</span> idx &gt; r:</span><br><span class="line">                neg = l * (r-l+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> idx &lt; l:</span><br><span class="line">                neg = prefix_left[r] - prefix_left[l-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                neg = prefix_left[r] - prefix_left[idx] + l * (idx-l+<span class="number">1</span>)</span><br><span class="line">            ans.append(base - neg)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="月11周赛">8月11周赛</h2>
<h3 id="统计好节点的数目">100354. 统计好节点的数目</h3>
<p>现有一棵 <strong>无向</strong> 树，树中包含 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 标记。树的根节点是节点 <code>0</code> 。给你一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code>，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 与节点 <code>bi</code> 之间存在一条边。</p>
<p>如果一个节点的所有子节点为根的子树包含的节点数相同，则认为该节点是一个 <strong>好节点</strong>。</p>
<p>返回给定树中 <strong>好节点</strong> 的数量。</p>
<p><strong>子树</strong> 指的是一个节点以及它所有后代节点构成的一棵树。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]</p>
<p><strong>输出：</strong>7</p>
<p><strong>说明：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/05/26/tree1.png" /></p>
<p>树的所有节点都是好节点。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]</p>
<p><strong>输出：</strong>6</p>
<p><strong>说明：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/03/screenshot-2024-06-03-193552.png" /></p>
<p>树中有 6 个好节点。上图中已将这些节点着色。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]</p>
<p><strong>输出：</strong>12</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/08/08/rob.jpg" /></p>
<p>除了节点 9 以外其他所有节点都是好节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li>输入确保 <code>edges</code> 总表示一棵有效的树。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-good-nodes/description/">https://leetcode.cn/problems/count-the-number-of-good-nodes/description/</a></p>
<p>简单dfs,可惜没写出来.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countGoodNodes</span>(<span class="params">self, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(edges) + <span class="number">1</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            graph[u].append(v)</span><br><span class="line">            graph[v].append(u)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">curr, parent</span>):</span><br><span class="line">            total = <span class="number">1</span></span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[curr]:</span><br><span class="line">                <span class="keyword">if</span> node != parent:</span><br><span class="line">                    size = dfs(node, curr)</span><br><span class="line">                    <span class="keyword">if</span> prev &gt; <span class="number">0</span> <span class="keyword">and</span> prev != size:</span><br><span class="line">                        found = <span class="literal">False</span></span><br><span class="line">                    prev = size</span><br><span class="line">                    total += size</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans += found</span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line">        dfs(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="单调数组对的数目-ii">100396. 单调数组对的数目 II</h3>
<p>给你一个长度为 <code>n</code> 的 <strong>正</strong> 整数数组 <code>nums</code> 。</p>
<p>如果两个 <strong>非负</strong> 整数数组 <code>(arr1, arr2)</code> 满足以下条件，我们称它们是 <strong>单调</strong> 数组对：</p>
<ul>
<li>两个数组的长度都是 <code>n</code> 。<br />
</li>
<li><code>arr1</code> 是单调 <strong>非递减</strong> 的，换句话说 <code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code> 。<br />
</li>
<li><code>arr2</code> 是单调 <strong>非递增</strong> 的，换句话说 <code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code> 。<br />
</li>
<li>对于所有的 <code>0 &lt;= i &lt;= n - 1</code> 都有 <code>arr1[i] + arr2[i] == nums[i]</code> 。</li>
</ul>
<p>请你返回所有 <strong>单调</strong> 数组对的数目。</p>
<p>由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [2,3,2]</p>
<p><strong>输出：</strong>4</p>
<p><strong>解释：</strong></p>
<p>单调数组对包括：</p>
<ol type="1">
<li><code>([0, 1, 1], [2, 2, 1])</code><br />
</li>
<li><code>([0, 1, 2], [2, 2, 0])</code><br />
</li>
<li><code>([0, 2, 2], [2, 1, 0])</code><br />
</li>
<li><code>([1, 2, 2], [1, 1, 0])</code></li>
</ol>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [5,5,5,5]</p>
<p><strong>输出：</strong>126</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/description/">https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/description/</a></p>
<p>第三题可以直接记忆化搜索, 但是第四题TLE</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countOfPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        min_lst = []</span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[::-<span class="number">1</span>]:</span><br><span class="line">            min_ = <span class="built_in">min</span>(min_, i)</span><br><span class="line">            min_lst.insert(<span class="number">0</span>, min_)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, prev_1, prev_2</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            target = nums[i]</span><br><span class="line">            <span class="keyword">if</span> prev_1 - prev_2 &gt; min_lst[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> a2 <span class="keyword">in</span> <span class="built_in">range</span>(prev_2, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> target - a2 &gt;= prev_1:</span><br><span class="line">                    tmp = dfs(i+<span class="number">1</span>, target-a2, a2) % mod_v</span><br><span class="line">                    <span class="keyword">if</span> tmp != <span class="number">0</span>:</span><br><span class="line">                        res += tmp</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> res % mod_v</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>前缀和优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countOfPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">max</span>(nums)</span><br><span class="line">        mod_v = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums[<span class="number">0</span>]+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># arr1填j</span></span><br><span class="line">        <span class="comment"># arr2为num[i]-j</span></span><br><span class="line">        <span class="comment"># 枚举i-1, 考虑arr1为k</span></span><br><span class="line">        <span class="comment"># 则arr2为num[i-1] - k</span></span><br><span class="line">        <span class="comment"># 则有num[i-1]-k &gt;= num[i]-j, k&lt;=j</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            s = <span class="built_in">list</span>(accumulate(dp[i-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nums[i]+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 此处枚举过程为前缀和, 所以直接提前计算</span></span><br><span class="line">                max_ = <span class="built_in">min</span>(j, nums[i-<span class="number">1</span>]-nums[i]+j)</span><br><span class="line">                dp[i][j] = s[max_] <span class="keyword">if</span> max_ &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(dp[-<span class="number">1</span>]) % mod_v</span><br></pre></td></tr></table></figure>
<h2 id="月4周赛">8月4周赛</h2>
<h3 id="新增道路查询后的最短距离-i">100379. 新增道路查询后的最短距离 I</h3>
<p>给你一个整数 <code>n</code> 和一个二维整数数组 <code>queries</code>。</p>
<p>有 <code>n</code> 个城市，编号从 <code>0</code> 到 <code>n - 1</code>。初始时，每个城市 <code>i</code> 都有一条<strong>单向</strong>道路通往城市 <code>i + 1</code>（ <code>0 &lt;= i &lt; n - 1</code>）。</p>
<p><code>queries[i] = [ui, vi]</code> 表示新建一条从城市 <code>ui</code> 到城市 <code>vi</code> 的<strong>单向</strong>道路。每次查询后，你需要找到从城市 <code>0</code> 到城市 <code>n - 1</code> 的<strong>最短路径</strong>的<strong>长度</strong>。</p>
<p>返回一个数组 <code>answer</code>，对于范围 <code>[0, queries.length - 1]</code> 中的每个 <code>i</code>，<code>answer[i]</code> 是处理完<strong>前</strong> <code>i + 1</code> 个查询后，从城市 <code>0</code> 到城市 <code>n - 1</code> 的最短路径的_长度_。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> n = 5, queries = [[2, 4], [0, 2], [0, 4]]</p>
<p><strong>输出：</strong> [3, 2, 1]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg" /></p>
<p>新增一条从 2 到 4 的道路后，从 0 到 4 的最短路径长度为 3。</p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg" /></p>
<p>新增一条从 0 到 2 的道路后，从 0 到 4 的最短路径长度为 2。</p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg" /></p>
<p>新增一条从 0 到 4 的道路后，从 0 到 4 的最短路径长度为 1。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> n = 4, queries = [[0, 3], [0, 2]]</p>
<p><strong>输出：</strong> [1, 1]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg" /></p>
<p>新增一条从 0 到 3 的道路后，从 0 到 3 的最短路径长度为 1。</p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg" /></p>
<p>新增一条从 0 到 2 的道路后，从 0 到 3 的最短路径长度仍为 1。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= queries.length &lt;= 500</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>0 &lt;= queries[i][0] &lt; queries[i][1] &lt; n</code></li>
<li><code>1 &lt; queries[i][1] - queries[i][0]</code></li>
<li>查询中没有重复的道路。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/description/">https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/description/</a></p>
<p>dijkstra或者floyd可直接解,floyd复杂度会偏高得改一下.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestDistanceAfterQueries</span>(<span class="params">self, n: <span class="built_in">int</span>, queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            g[i].append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">g</span>):</span><br><span class="line">            ans = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n</span><br><span class="line">            q = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                w, v = heapq.heappop(q)</span><br><span class="line">                <span class="keyword">if</span> w &gt; ans[v]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> g[v]:</span><br><span class="line">                    <span class="keyword">if</span> ans[node] &gt; <span class="number">1</span> + w:</span><br><span class="line">                        ans[node] = <span class="number">1</span> + w</span><br><span class="line">                        heapq.heappush(q, [<span class="number">1</span>+w, node])</span><br><span class="line">            <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(queries)</span><br><span class="line">        <span class="keyword">for</span> i, (u, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">            g[u].append(v)</span><br><span class="line">            ans[i] = dijkstra(g)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="新增道路查询后的最短距离-ii">100376. 新增道路查询后的最短距离 II</h3>
<p>给你一个整数 <code>n</code> 和一个二维整数数组 <code>queries</code>。</p>
<p>有 <code>n</code> 个城市，编号从 <code>0</code> 到 <code>n - 1</code>。初始时，每个城市 <code>i</code> 都有一条<strong>单向</strong>道路通往城市 <code>i + 1</code>（ <code>0 &lt;= i &lt; n - 1</code>）。</p>
<p><code>queries[i] = [ui, vi]</code> 表示新建一条从城市 <code>ui</code> 到城市 <code>vi</code> 的<strong>单向</strong>道路。每次查询后，你需要找到从城市 <code>0</code> 到城市 <code>n - 1</code> 的<strong>最短路径</strong>的<strong>长度</strong>。</p>
<p>所有查询中不会存在两个查询都满足 <code>queries[i][0] &lt; queries[j][0] &lt; queries[i][1] &lt; queries[j][1]</code>。</p>
<p>返回一个数组 <code>answer</code>，对于范围 <code>[0, queries.length - 1]</code> 中的每个 <code>i</code>，<code>answer[i]</code> 是处理完<strong>前</strong> <code>i + 1</code> 个查询后，从城市 <code>0</code> 到城市 <code>n - 1</code> 的最短路径的_长度_。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> n = 5, queries = [[2, 4], [0, 2], [0, 4]]</p>
<p><strong>输出：</strong> [3, 2, 1]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg" /></p>
<p>新增一条从 2 到 4 的道路后，从 0 到 4 的最短路径长度为 3。</p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg" /></p>
<p>新增一条从 0 到 2 的道路后，从 0 到 4 的最短路径长度为 2。</p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg" /></p>
<p>新增一条从 0 到 4 的道路后，从 0 到 4 的最短路径长度为 1。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> n = 4, queries = [[0, 3], [0, 2]]</p>
<p><strong>输出：</strong> [1, 1]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg" /></p>
<p>新增一条从 0 到 3 的道路后，从 0 到 3 的最短路径长度为 1。</p>
<p><img src="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg" /></p>
<p>新增一条从 0 到 2 的道路后，从 0 到 3 的最短路径长度仍为 1。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>3 &lt;= n &lt;= 105</code><br />
</li>
<li><code>1 &lt;= queries.length &lt;= 105</code><br />
</li>
<li><code>queries[i].length == 2</code><br />
</li>
<li><code>0 &lt;= queries[i][0] &lt; queries[i][1] &lt; n</code><br />
</li>
<li><code>1 &lt; queries[i][1] - queries[i][0]</code><br />
</li>
<li>查询中不存在重复的道路。<br />
</li>
<li>不存在两个查询都满足 <code>i != j</code> 且 <code>queries[i][0] &lt; queries[j][0] &lt; queries[i][1] &lt; queries[j][1]</code>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-ii/description/">https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-ii/description/</a></p>
<p>其实是个贪心的思路, 不过纯按贪心会超时.</p>
<p>纯贪心做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestDistanceAfterQueries</span>(<span class="params">self, n: <span class="built_in">int</span>, queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = SortedList(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> queries:</span><br><span class="line">            q.add((u,v))</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">2</span> <span class="keyword">and</span> q[<span class="number">0</span>][<span class="number">0</span>] == q[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                q.pop(<span class="number">1</span>)</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            curr_res = <span class="number">0</span></span><br><span class="line">            cp_q = q.copy()</span><br><span class="line">            furthest = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cp_q:</span><br><span class="line">                curr_u, curr_v = cp_q.pop(<span class="number">0</span>)</span><br><span class="line">                furthest = <span class="built_in">max</span>(furthest, curr_v)</span><br><span class="line">                <span class="keyword">if</span> curr_u &gt;= curr:</span><br><span class="line">                    curr_res += <span class="number">1</span> + (curr_u - curr)</span><br><span class="line">                    curr = curr_v</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            ans.append(curr_res + n-<span class="number">1</span>-furthest)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>正解是用区间并查集, 对query里面的区间进行合并, 需要注意root_u需要用find(root_u+1)来加速, 这样可以忽略中间过程.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestDistanceAfterQueries</span>(<span class="params">self, n: <span class="built_in">int</span>, queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        fa = <span class="built_in">list</span>(<span class="built_in">range</span>(n-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">u</span>):</span><br><span class="line">            <span class="keyword">while</span> fa[u] != u:</span><br><span class="line">                fa[u] = fa[fa[u]]</span><br><span class="line">                u = fa[u]</span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(queries)</span><br><span class="line">        count = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, (u, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">            root_u = find(u)</span><br><span class="line">            root_v = find(v-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> root_u &lt; v-<span class="number">1</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                fa[root_u] = root_v</span><br><span class="line">                root_u = find(root_u+<span class="number">1</span>)</span><br><span class="line">            ans[i] = count</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="交替组-iii">3245. 交替组 III</h3>
<p>这题就不贴了, 看了答案知道思路都写不出来. 简单表述就是用两个树状数组, 一个存count, 一个存sum, 然后用一个sortedList存切分位置, 对于1类query还是好求的, 但是问题是碰到二类query的时候做update情况太复杂了.(或许可以针对len(end_pos)为0和1的情况直接求解不做update, 仅对长度为2及以上的end_pos做update?).</p>
<h2 id="月28周赛">7月28周赛</h2>
<h3 id="统计不是特殊数字的数字数量">100371. 统计不是特殊数字的数字数量</h3>
<p>给你两个 <strong>正整数</strong> <code>l</code> 和 <code>r</code>。对于任何数字 <code>x</code>，<code>x</code> 的所有正因数（除了 <code>x</code> 本身）被称为 <code>x</code> 的 <strong>真因数</strong>。</p>
<p>如果一个数字恰好仅有两个 <strong>真因数</strong>，则称该数字为 <strong>特殊数字</strong>。例如：</p>
<ul>
<li>数字 4 是 <strong>特殊数字</strong>，因为它的真因数为 1 和 2。<br />
</li>
<li>数字 6 不是 <strong>特殊数字</strong>，因为它的真因数为 1、2 和 3。</li>
</ul>
<p>返回区间 <code>[l, r]</code> 内 <strong>不是 特殊数字</strong> 的数字数量。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> l = 5, r = 7</p>
<p><strong>输出：</strong> 3</p>
<p><strong>解释：</strong></p>
<p>区间 <code>[5, 7]</code> 内不存在特殊数字。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> l = 4, r = 16</p>
<p><strong>输出：</strong> 11</p>
<p><strong>解释：</strong></p>
<p>区间 <code>[4, 16]</code> 内的特殊数字为 4 和 9。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= l &lt;= r &lt;= 10^9</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-numbers-which-are-not-special/description/">https://leetcode.cn/problems/find-the-count-of-numbers-which-are-not-special/description/</a></p>
<p>题目很简单, 不过多写一些新东西.</p>
<ol type="1">
<li>质数筛选这个以前就学过, 不过这里多加一个欧拉筛.<br />
</li>
<li>灵神写了个直接算质数数量的前缀和, 简要学习.<br />
</li>
<li>评论还有切片的埃筛方法.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Eratosthenes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        is_prime = [<span class="literal">True</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        prime = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">                prime.append(i)</span><br><span class="line">                curr = i * i</span><br><span class="line">                <span class="keyword">while</span> curr &lt;= n:</span><br><span class="line">                    is_prime[curr] = <span class="literal">False</span></span><br><span class="line">                    curr += i</span><br><span class="line">        <span class="keyword">return</span> prime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Euler</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        is_prime = [<span class="literal">True</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        prime = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">                prime.append(i)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> prime:</span><br><span class="line">                <span class="keyword">if</span> p * i &gt; n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                is_prime[p*i] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> i % p == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prime</span><br></pre></td></tr></table></figure>
<p>前缀和和切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAX = isqrt(<span class="number">10</span> ** <span class="number">9</span>) + <span class="number">1</span></span><br><span class="line">pi = [<span class="number">0</span>] * (MAX + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, MAX+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> pi[i] == <span class="number">0</span>:</span><br><span class="line">        pi[i] = pi[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        pi[i*i::i] = [-<span class="number">1</span>] * ((MAX - i*i) // i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pi[i] = pi[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="统计-1-显著的字符串的数量">100348. 统计 1 显著的字符串的数量</h3>
<p>给你一个二进制字符串 <code>s</code>。</p>
<p>请你统计并返回其中 <strong>1 显著</strong> 的子字符串的数量。</p>
<p>如果字符串中 1 的数量 <strong>大于或等于</strong> 0 的数量的 <strong>平方</strong>，则认为该字符串是一个 <strong>1 显著</strong> 的字符串 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>s = "00011"</p>
<p><strong>输出：</strong>5</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>s = "101101"</p>
<p><strong>输出：</strong>16</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4 * 104</code></li>
<li><code>s</code> 仅包含字符 <code>'0'</code> 和 <code>'1'</code>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/description/">https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/description/</a></p>
<p>testcase的格式有问题就不列表了, 题目描述得已经很清楚了.</p>
<p>这题非常恶心, 给的范围是4*10e4, 预期解的AC时间直接10000ms. 我一开始以为有数学方面的优化, 算了一下发现并不行, 然后尝试暴力, TLE了, 很正常; 尝试对0的数量加一个threshold, 还是TLE; 然后考虑是不是简化流程, 不去枚举i而是枚举0, 结果关系没找出来, 卡在了最后一步.</p>
<p>最终思路是两层循环, 外层表示子串起始位置, 内层表示0的位置, 同时一旦检测0的数量超过threshold就break.</p>
<p>最关键的部分是对0的处理, 从上一个0的idx到下一个0的idx:</p>
<ul>
<li>如果我们第一个0已经满足了题意要求, 那么我们可以直接 <code>ans += next_zero_idx - curr_zero_idx</code><br />
</li>
<li>如果我们不满足题意要求, 还需要额外0, 那么我们就得 <code>ans += max(next_zero_idx - curr_zero_idx - (count_0 ^ 2 - count_1, 0)</code><br />
</li>
<li>所以最终可以写成 <code>ans += max(next_zero_idx - curr_zero_idx - max(count_0 ^ 2 - count_1, 0),0)</code></li>
</ul>
<p>然后就是新学到的小技巧, 如果题目卡常数, 可以手写大小比较来加速计算. 没什么大用, 感觉会卡常数的题目都没啥大意思.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        zeros = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> s[j] == <span class="string">&#x27;0&#x27;</span>] + [n]</span><br><span class="line">        total_one = n - <span class="built_in">len</span>(zeros) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a,b</span>): <span class="keyword">return</span> a <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> b</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        zero_idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                ans += zeros[zero_idx] - idx</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(zero_idx, <span class="built_in">len</span>(zeros)-<span class="number">1</span>):</span><br><span class="line">                count_z = k-zero_idx+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count_z * count_z &gt; total_one:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                count_o =(zeros[k] - idx) - (k - zero_idx)</span><br><span class="line">                ans += <span class="built_in">max</span>(zeros[k+<span class="number">1</span>]-zeros[k] - <span class="built_in">max</span>(count_z * count_z - count_o, <span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                zero_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="判断矩形的两个角落是否可达">100347. 判断矩形的两个角落是否可达</h3>
<p>给你两个正整数 <code>X</code> 和 <code>Y</code> 和一个二维整数数组 <code>circles</code> ，其中 <code>circles[i] = [xi, yi, ri]</code> 表示一个圆心在 <code>(xi, yi)</code> 半径为 <code>ri</code> 的圆。</p>
<p>坐标平面内有一个左下角在原点，右上角在 <code>(X, Y)</code> 的矩形。你需要判断是否存在一条从左下角到右上角的路径满足：路径 <strong>完全</strong> 在矩形内部，<strong>不会</strong> 触碰或者经过 <strong>任何</strong> 圆的内部和边界，同时 <strong>只</strong> 在起点和终点接触到矩形。</p>
<p>如果存在这样的路径，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>X = 3, Y = 4, circles = [[2,1,1]]</p>
<p><strong>输出：</strong>true</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/05/18/example2circle1.png" /></p>
<p>黑色曲线表示一条从 <code>(0, 0)</code> 到 <code>(3, 4)</code> 的路径。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>X = 3, Y = 3, circles = [[1,1,2]]</p>
<p><strong>输出：</strong>false</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/05/18/example1circle.png" /></p>
<p>不存在从 <code>(0, 0)</code> 到 <code>(3, 3)</code> 的路径。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>X = 3, Y = 3, circles = [[2,1,1],[1,2,1]]</p>
<p><strong>输出：</strong>false</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/05/18/example0circle.png" /></p>
<p>不存在从 <code>(0, 0)</code> 到 <code>(3, 3)</code> 的路径。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= X, Y &lt;= 109</code></li>
<li><code>1 &lt;= circles.length &lt;= 1000</code></li>
<li><code>circles[i].length == 3</code></li>
<li><code>1 &lt;= xi, yi, ri &lt;= 109</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-if-the-rectangle-corner-is-reachable/description/">https://leetcode.cn/problems/check-if-the-rectangle-corner-is-reachable/description/</a></p>
<p>周赛第四题, 存在两种思路: 一种是并查集, 另一种是简化版的并查集, 因为最终判断只用考虑两个边界, 那么我们直接考虑其中一个边界的连通性然后每次逐一判断和另一边界的关系就行了.</p>
<p><del>个人感觉比第三题简单</del> test case过于简单了, 假设存在一堆小圆围绕右顶点, 仅留一丝缝隙让路径穿过, 那么并查集做法会认为此方案不可行, 因为连通了上面和右边边界, 但其实实际是可行的.</p>
<p>假设圆心都在矩形内部: 并查集思路, 我个人是连通圆做集合然后判断是否触碰边界, 也能过, 不过存在更简单的做法, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-if-the-rectangle-corner-is-reachable/solutions/2860214/deng-jie-zhuan-huan-bing-cha-ji-pythonja-yf9y">等价转换+并查集（Python/Java/C++/Go）</a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canReachCorner</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, a: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(a)</span><br><span class="line">        <span class="comment"># 并查集中的 n 表示左边界或上边界，n+1 表示下边界或右边界</span></span><br><span class="line">        fa = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 非递归并查集</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            rt = x</span><br><span class="line">            <span class="keyword">while</span> fa[rt] != rt:</span><br><span class="line">                rt = fa[rt]</span><br><span class="line">            <span class="keyword">while</span> fa[x] != rt:</span><br><span class="line">                fa[x], x = rt, fa[x]</span><br><span class="line">            <span class="keyword">return</span> rt</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            fa[find(x)] = find(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, (ox, oy, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">            <span class="keyword">if</span> ox &lt;= r <span class="keyword">or</span> oy + r &gt;= y:  <span class="comment"># 圆 i 和左边界或上边界有交集</span></span><br><span class="line">                merge(i, n)</span><br><span class="line">            <span class="keyword">if</span> oy &lt;= r <span class="keyword">or</span> ox + r &gt;= x:  <span class="comment"># 圆 i 和下边界或右边界有交集</span></span><br><span class="line">                merge(i, n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j, (qx, qy, qr) <span class="keyword">in</span> <span class="built_in">enumerate</span>(a[:i]):</span><br><span class="line">                <span class="keyword">if</span> (ox - qx) * (ox - qx) + (oy - qy) * (oy - qy) &lt;= (r + qr) * (r + qr):</span><br><span class="line">                    merge(i, j)  <span class="comment"># 圆 i 和圆 j 有交集</span></span><br><span class="line">            <span class="keyword">if</span> find(n) == find(n + <span class="number">1</span>):  <span class="comment"># 无法到达终点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>单边界加判断的做法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canReachCorner</span>(<span class="params">self, X: <span class="built_in">int</span>, Y: <span class="built_in">int</span>, circles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(circles)</span><br><span class="line">        vis = [<span class="literal">False</span>] * n</span><br><span class="line">        </span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i, (x, y, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(circles):</span><br><span class="line">            <span class="keyword">if</span> y + r &gt;= Y <span class="keyword">or</span> x - r &lt;= <span class="number">0</span>:</span><br><span class="line">                vis[i] = <span class="literal">True</span></span><br><span class="line">                q.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>:</span><br><span class="line">            j = q.popleft()</span><br><span class="line">            xj, yj, rj = circles[j]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> xj + rj &gt;= X <span class="keyword">or</span> yj - rj &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i, (x, y, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(circles):</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> vis[i]) <span class="keyword">and</span> (xj - x) ** <span class="number">2</span> + (yj - y) ** <span class="number">2</span> &lt;= (r + rj) ** <span class="number">2</span>:</span><br><span class="line">                    vis[i] = <span class="literal">True</span></span><br><span class="line">                    q.append(i)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="树状数组">树状数组</h2>
<h3 id="统计作战单位数">1395. 统计作战单位数</h3>
<p> <code>n</code> 名士兵站成一排。每个士兵都有一个 <strong>独一无二</strong> 的评分 <code>rating</code> 。</p>
<p>从中选出 <strong>3</strong> 个士兵组成一个作战单位，规则如下：</p>
<ul>
<li>从队伍中选出下标分别为 <code>i</code>、<code>j</code>、<code>k</code> 的 3 名士兵，他们的评分分别为 <code>rating[i]</code>、<code>rating[j]</code>、<code>rating[k]</code><br />
</li>
<li>作战单位需满足： <code>rating[i] &lt; rating[j] &lt; rating[k]</code> 或者 <code>rating[i] &gt; rating[j] &gt; rating[k]</code> ，其中  <code>0 &lt;= i &lt; j &lt; k &lt; n</code></li>
</ul>
<p>请你返回按上述条件组建的作战单位的方案数。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>rating = [2,5,3,4,1]<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>rating = [2,1,3]<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>根据题目条件，我们无法组建作战单位。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>rating = [1,2,3,4]<br />
<strong>输出：</strong>4</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == rating.length</code></li>
<li><code>3 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= rating[i] &lt;= 10^5</code></li>
<li><code>rating</code> 中的元素都是唯一的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-teams/solutions/1460260/by-flix-3lu9/">https://leetcode.cn/problems/count-number-of-teams/solutions/1460260/by-flix-3lu9/</a></p>
<p>不算很困难, 但是解法却很多, 除了我自己想出来的暴力, 每个都比我想的好.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-teams/solutions/1460260/by-flix-3lu9">『 一题四解 』 暴力枚举 + 有序数组 + 树状数组 + 线段树</a></p>
<ol type="1">
<li>暴力</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTeams</span>(<span class="params">self, rating: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(rating)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            pre = <span class="number">0</span></span><br><span class="line">            post = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &lt; rating[i]:</span><br><span class="line">                    pre += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &gt; rating[i]:</span><br><span class="line">                    post += <span class="number">1</span></span><br><span class="line">            ans += pre * post</span><br><span class="line">            ans += (i - pre) * (n-i-<span class="number">1</span>-post)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>SortedList</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTeams</span>(<span class="params">self, rating: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sl1 = SortedList()</span><br><span class="line">        sl2 = SortedList(rating)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(rating)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sm1 = sl1.bisect_left(rating[i])</span><br><span class="line">            lg1 = i - sm1</span><br><span class="line"></span><br><span class="line">            sl1.add(rating[i])</span><br><span class="line">            sl2.remove(rating[i])</span><br><span class="line"></span><br><span class="line">            sm2 = sl2.bisect_left(rating[i])</span><br><span class="line">            lg2 = n - <span class="number">1</span> - i - sm2</span><br><span class="line"></span><br><span class="line">            ans += sm1 * lg2 + sm2 * lg1</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/fenwick/">树状数组</a></li>
</ol>
<p>树状数组是一种支持单点修改和区间查询的代码量最小的数据结构,具体可以点上面的wiki看.</p>
<p>这里也可以用树状数组来做.</p>
<p>存数字的rank的前缀和, query[rank-1]的数值表示在这个数前面小于rank的数字数量, 而i - sm1就是在这个数前面且大于这个数的数量, rank表示总共小于这个数的数量, 所以可以推出在这个数后面小于这个数的数量和大于这个数的数量.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTeams</span>(<span class="params">self, rating: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        keys = <span class="built_in">sorted</span>(rating)</span><br><span class="line">        rank_map = &#123;v:i+<span class="number">1</span> <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(keys)&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(rank_map)</span><br><span class="line">        tree = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, delta</span>):</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> x &lt; <span class="built_in">len</span>(tree):</span><br><span class="line">                    tree[x] += delta</span><br><span class="line">                    x += lowbit(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                res += tree[x]</span><br><span class="line">                x -= lowbit(x)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            rank = rank_map[rating[i]]</span><br><span class="line">            add(rank, <span class="number">1</span>)</span><br><span class="line">            sm1 = query(rank - <span class="number">1</span>)</span><br><span class="line">            lg1 = i - sm1</span><br><span class="line">            sm2 = rank - <span class="number">1</span> - sm1</span><br><span class="line">            lg2 = n-<span class="number">1</span>-i - sm2</span><br><span class="line">            ans += sm1 * lg2 + sm2 * lg1</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>同样, 树状数组可以做的题, 线段树也可以.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTeams</span>(<span class="params">self, rating: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;线段树模板&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, delta</span>):          <span class="comment"># 坐标i处依次添加delta</span></span><br><span class="line">            i += <span class="built_in">len</span>(tree)//<span class="number">2</span>       <span class="comment"># 转换到线段树下标</span></span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                tree[i] += delta</span><br><span class="line">                i //= <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">i, j</span>):            <span class="comment"># 区域和检索 range sum</span></span><br><span class="line">            i += <span class="built_in">len</span>(tree) // <span class="number">2</span>     <span class="comment"># 转换到线段树下标</span></span><br><span class="line">            j += <span class="built_in">len</span>(tree) // <span class="number">2</span></span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:      <span class="comment"># i为右子树</span></span><br><span class="line">                    summ += tree[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j % <span class="number">2</span> == <span class="number">0</span>:      <span class="comment"># i为左子树</span></span><br><span class="line">                    summ += tree[j]</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                i //= <span class="number">2</span></span><br><span class="line">                j //= <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> summ</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;主程序&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 离散化：绝对数值转秩次rank</span></span><br><span class="line">        uniques = <span class="built_in">sorted</span>(rating)        <span class="comment"># rating没有重复值</span></span><br><span class="line">        rank_map = &#123;v:i <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(uniques)&#125;    <span class="comment">#【注意：rank从0开始】</span></span><br><span class="line">        <span class="comment"># print(rank_map)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建线段树</span></span><br><span class="line">        tree = [<span class="number">0</span>] * (<span class="built_in">len</span>(rank_map) * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举中间点</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(rating)</span><br><span class="line">        add(rank_map[rating[<span class="number">0</span>]], <span class="number">1</span>)     <span class="comment"># 先将第一个元素入列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n-<span class="number">1</span>):         <span class="comment"># 从第二个元素开始遍历，直至倒数第二个元素</span></span><br><span class="line">            rank = rank_map[rating[i]]  <span class="comment"># 当前元素的排名/秩次</span></span><br><span class="line"></span><br><span class="line">            small1 = query(<span class="number">0</span>, rank-<span class="number">1</span>)   <span class="comment"># 查询前序元素中排名&lt;rank的元素数目</span></span><br><span class="line">            large1 = i - small1         <span class="comment"># small1 + large1 = i</span></span><br><span class="line"></span><br><span class="line">            small2 = rank - small1      <span class="comment"># small1 + small2 = rank</span></span><br><span class="line">            large2 = n-<span class="number">1</span> - i - small2   <span class="comment"># small2 + large2 = n-1-i</span></span><br><span class="line"></span><br><span class="line">            add(rank, <span class="number">1</span>)                <span class="comment"># 当前元素入列</span></span><br><span class="line"></span><br><span class="line">            ans += small1*large2 + large1*small2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="线段树">线段树</h2>
<h3 id="掉落的方块">699. 掉落的方块</h3>
<p>在二维平面上的 x 轴上，放置着一些方块。</p>
<p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [lefti, sideLengthi]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLengthi</code> ，其左侧边与 x 轴上坐标点 <code>lefti</code> 对齐。</p>
<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
<p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>
<p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg" /></p>
<p><strong>输入：</strong>positions = [[1,2],[2,3],[6,1]]<br />
<strong>输出：</strong>[2,5,5]<br />
<strong>解释：</strong><br />
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。<br />
第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。<br />
第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。<br />
因此，返回 [2, 5, 5] 作为答案。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>positions = [[100,100],[200,100]]<br />
<strong>输出：</strong>[100,100]<br />
<strong>解释：</strong><br />
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。<br />
第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。<br />
因此，返回 [100, 100] 作为答案。<br />
注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= positions.length &lt;= 1000</code></li>
<li><code>1 &lt;= lefti &lt;= 108</code></li>
<li><code>1 &lt;= sideLengthi &lt;= 106</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/description/?envType=daily-question&amp;envId=2024-07-28">https://leetcode.cn/problems/falling-squares/description/?envType=daily-question&amp;envId=2024-07-28</a></p>
<p>听说过但是没写过, 看到这个题第一眼感觉好像是线段树, 但是从来没写过. 找了个板子, 做个记录. 其中pushdown是用父节点的add来更新子节点, 写成方法方便递归的时候顺便调用来维护子节点和父节点一致, pushup则是用子节点更新父节点, 与pushdown类似.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode.cn/problems/falling-squares/solutions/2859880/python3javacgotypescript-yi-ti-yi-jie-xi-ju2s</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, l, r</span>):</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.l = l</span><br><span class="line">        self.r = r</span><br><span class="line">        self.mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        self.v = <span class="number">0</span></span><br><span class="line">        self.add = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = Node(<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">1e9</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">self, l, r, v, node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node = self.root</span><br><span class="line">        <span class="keyword">if</span> node.l &gt;= l <span class="keyword">and</span> node.r &lt;= r:</span><br><span class="line">            node.v = v</span><br><span class="line">            node.add = v</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pushdown(node)</span><br><span class="line">        <span class="keyword">if</span> l &lt;= node.mid:</span><br><span class="line">            self.modify(l, r, v, node.left)</span><br><span class="line">        <span class="keyword">if</span> r &gt; node.mid:</span><br><span class="line">            self.modify(l, r, v, node.right)</span><br><span class="line">        self.pushup(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, l, r, node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node = self.root</span><br><span class="line">        <span class="keyword">if</span> node.l &gt;= l <span class="keyword">and</span> node.r &lt;= r:</span><br><span class="line">            <span class="keyword">return</span> node.v</span><br><span class="line">        self.pushdown(node)</span><br><span class="line">        v = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l &lt;= node.mid:</span><br><span class="line">            v = <span class="built_in">max</span>(v, self.query(l, r, node.left))</span><br><span class="line">        <span class="keyword">if</span> r &gt; node.mid:</span><br><span class="line">            v = <span class="built_in">max</span>(v, self.query(l, r, node.right))</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pushup</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.v = <span class="built_in">max</span>(node.left.v, node.right.v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pushdown</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node.left = Node(node.l, node.mid)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node.right = Node(node.mid + <span class="number">1</span>, node.r)</span><br><span class="line">        <span class="keyword">if</span> node.add:</span><br><span class="line">            node.left.v = node.add</span><br><span class="line">            node.right.v = node.add</span><br><span class="line">            node.left.add = node.add</span><br><span class="line">            node.right.add = node.add</span><br><span class="line">            node.add = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fallingSquares</span>(<span class="params">self, positions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        tree = SegmentTree()</span><br><span class="line">        <span class="keyword">for</span> l, w <span class="keyword">in</span> positions:</span><br><span class="line">            r = l + w - <span class="number">1</span></span><br><span class="line">            h = tree.query(l, r) + w</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, h)</span><br><span class="line">            ans.append(mx)</span><br><span class="line">            tree.modify(l, r, h)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>也存在二分做法, 用一个列表维护区间, 一个列表维护高度.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode.cn/problems/falling-squares/solutions/2859890/er-fen-chu-li-ji-jian-shu-xing-dai-ma-by-ezgn</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fallingSquares</span>(<span class="params">self, positions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        lstp, lsth, ma, ans = [<span class="number">0</span>, inf], [<span class="number">0</span>], <span class="number">0</span>, [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> x, a <span class="keyword">in</span> positions:</span><br><span class="line">            i, j = bisect_right(lstp, x), bisect_left(lstp, x + a)</span><br><span class="line">            ma = <span class="built_in">max</span>(lsth[i - <span class="number">1</span> : j]) + a</span><br><span class="line">            lstp, lsth = lstp[: i] + [x, x + a] + lstp[j :], lsth[: i] + [ma] + lsth[j - <span class="number">1</span> :]                </span><br><span class="line">            ans.append(<span class="built_in">max</span>(ans[-<span class="number">1</span>], ma))</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">1</span> :]</span><br></pre></td></tr></table></figure>
<h2 id="差分数组">差分数组</h2>
<p>第一次见, 先熟悉一下.</p>
<h3 id="拼车">1094. 拼车</h3>
<p>车上最初有 <code>capacity</code> 个空座位。车 <strong>只能</strong> 向一个方向行驶（也就是说，<strong>不允许掉头或改变方向</strong>）</p>
<p>给定整数 <code>capacity</code> 和一个数组 <code>trips</code> ,  <code>trip[i] = [numPassengers_i, from_i, to_i]</code> 表示第 <code>i</code> 次旅行有 <code>numPassengers_i</code> 乘客，接他们和放他们的位置分别是 <code>from_i</code> 和 <code>to_i</code> 。这些位置是从汽车的初始位置向东的公里数。</p>
<p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回 <code>true</code>，否则请返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 4<br />
<strong>输出：</strong>false</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 5<br />
<strong>输出：</strong>true</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= trips.length &lt;= 1000</code></li>
<li><code>trips[i].length == 3</code></li>
<li><code>1 &lt;= numPassengersi &lt;= 100</code></li>
<li><code>0 &lt;= fromi &lt; toi &lt;= 1000</code></li>
<li><code>1 &lt;= capacity &lt;= 105</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/car-pooling/description/">https://leetcode.cn/problems/car-pooling/description/</a></p>
<p>明确一点, 原数组某一段子数组同增同减某个数字可以看作差分数组首位的变化.</p>
<p>具体可以看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra">【算法小课堂】差分数组（附题单）Python/Java/C++/Go/JS/Rust</a></p>
<p>这里通过记录某节点的增减, 直接构造差分数组, 然后从差分数组还原原数组, 判断所有节点是否超过capacity.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        d = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line">        <span class="keyword">for</span> num, from_, to <span class="keyword">in</span> trips:</span><br><span class="line">            d[from_] += num</span><br><span class="line">            d[to] -= num</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">            start += i</span><br><span class="line">            <span class="keyword">if</span> start &gt; capacity:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="使数组等于目标数组所需的最少操作次数">100329. 使数组等于目标数组所需的最少操作次数</h3>
<p>给你两个长度相同的正整数数组 <code>nums</code> 和 <code>target</code>。</p>
<p>在一次操作中，你可以选择 <code>nums</code> 的任何子数组，并将该子数组内的每个元素的值增加或减少 1。</p>
<p>返回使 <code>nums</code> 数组变为 <code>target</code> 数组所需的 <strong>最少</strong> 操作次数。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> nums = [3,5,1,2], target = [4,6,2,4]</p>
<p><strong>输出：</strong> 2</p>
<p><strong>解释：</strong></p>
<p>执行以下操作可以使 <code>nums</code> 等于 <code>target</code>：<br />
- <code>nums[0..3]</code> 增加 1，<code>nums = [4,6,2,3]</code>。<br />
- <code>nums[3..3]</code> 增加 1，<code>nums = [4,6,2,4]</code>。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> nums = [1,3,2], target = [2,1,4]</p>
<p><strong>输出：</strong> 5</p>
<p><strong>解释：</strong></p>
<p>执行以下操作可以使 <code>nums</code> 等于 <code>target</code>：<br />
- <code>nums[0..0]</code> 增加 1，<code>nums = [2,3,2]</code>。<br />
- <code>nums[1..1]</code> 减少 1，<code>nums = [2,2,2]</code>。<br />
- <code>nums[1..1]</code> 减少 1，<code>nums = [2,1,2]</code>。<br />
- <code>nums[2..2]</code> 增加 1，<code>nums = [2,1,3]</code>。<br />
- <code>nums[2..2]</code> 增加 1，<code>nums = [2,1,4]</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length == target.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], target[i] &lt;= 108</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-make-array-equal-to-target/description/">https://leetcode.cn/problems/minimum-operations-to-make-array-equal-to-target/description/</a></p>
<p>同样是对子数组处理, 我们可以直接构造差分数组, 然后前面每有值加一就可以免费让后面值减一, 最终结果是所有正数和和所有负数和的绝对值里面取.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        diff = [nums[i]-target[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        neg = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            diff[i] -= diff[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                pos += diff[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                neg -= diff[i]</span><br><span class="line">        <span class="keyword">if</span> diff[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            pos += diff[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            neg -= diff[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(pos, neg)</span><br></pre></td></tr></table></figure>
<h2 id="并查集">并查集</h2>
<h3 id="账户合并">721. 账户合并</h3>
<p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称 (name)</em>，其余元素是 <em><strong>emails</strong></em> 表示该账户的邮箱地址。</p>
<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>
<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 <strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以 <strong>任意顺序</strong> 返回。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]<br />
<strong>输出：</strong>[["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]<br />
<strong>解释：</strong><br />
第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 "johnsmith@mail.com"。<br />
第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。<br />
可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']， ['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]<br />
<strong>输出：</strong>[["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>
<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>
<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>
<li><code>accounts[i][0]</code> 由英文字母组成</li>
<li><code>accounts[i][j] (for j &gt; 0)</code> 是有效的邮箱地址</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/accounts-merge/description/?envType=daily-question&amp;envId=2024-07-21">https://leetcode.cn/problems/accounts-merge/description/?envType=daily-question&amp;envId=2024-07-21</a></p>
<p>见过并查集, 但是没完全理解. 这里邮箱之间可以建立连接关系, 所以可以用并查集, 并查集可以缩短路径减少查找时间.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.node = &#123;&#125;</span><br><span class="line">        self.size = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.node.get(node) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.node[node] = node</span><br><span class="line">            self.size[node] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.node[node] != node:</span><br><span class="line">            self.node[node] = self.node[self.node[node]]</span><br><span class="line">            node = self.node[node]</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        root_p = self.find(p)</span><br><span class="line">        root_q = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> root_p == root_q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.size[root_p] &gt; self.size[root_q]:</span><br><span class="line">            self.node[root_q] = root_p</span><br><span class="line">            self.size[root_p] += self.size[root_q]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.node[root_p] = root_q</span><br><span class="line">            self.size[root_q] += self.size[root_p]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accountsMerge</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        email_to_name = &#123;&#125;</span><br><span class="line">        uf = UnionFind()</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line">            name = account[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(account)):</span><br><span class="line">                email_to_name[account[i]] = name</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(account) - <span class="number">1</span>:</span><br><span class="line">                    uf.union(account[i],account[i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> email_to_name:</span><br><span class="line">            d[uf.find(email)].add(email)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">            ans.append([email_to_name[k]] + <span class="built_in">list</span>(<span class="built_in">sorted</span>(v)))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="图">图</h1>
<h2 id="tarjan">tarjan</h2>
<h3 id="使陆地分离的最少天数">1568. 使陆地分离的最少天数</h3>
<p>给你一个大小为 <code>m x n</code> ，由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>1</code> 表示陆地， <code>0</code> 表示水。<strong>岛屿</strong> 由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>
<p>如果 <strong>恰好只有一座岛屿</strong> ，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>
<p>一天内，可以将 <strong>任何单个</strong> 陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>
<p>返回使陆地分离的最少天数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/12/24/land1.jpg" /></p>
<p><strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>至少需要 2 天才能得到分离的陆地。<br />
将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/12/24/land2.jpg" /></p>
<p><strong>输入：</strong>grid = [[1,1]]<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 30</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solutions/2754484/tarjansuan-fa-mo-ban-ti-qiu-qiang-lian-t-41ve/">https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solutions/2754484/tarjansuan-fa-mo-ban-ti-qiu-qiang-lian-t-41ve/</a></p>
<p>可以很简单, 直接当岛屿数量来做, 然后枚举所有1, 一旦成功返回1, 否则返回2.</p>
<p>也可以很难, 需要用到tarjan算法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solutions/2754484/tarjansuan-fa-mo-ban-ti-qiu-qiang-lian-t-41ve</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDays</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先用并查集看有多少个连通块，若不等于1，返回0</span></span><br><span class="line">        <span class="comment"># 若等于1，tarjan算法求割点，若不存在，返回2，反之返回1</span></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        fa = <span class="built_in">list</span>(<span class="built_in">range</span>(m * n))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x_: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> fa[x_] != x_:</span><br><span class="line">                fa[x_] = find(fa[x_])</span><br><span class="line">            <span class="keyword">return</span> fa[x_]</span><br><span class="line"></span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m * n)]</span><br><span class="line">        vis = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        cc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> v == <span class="number">0</span> <span class="keyword">or</span> vis[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur = [(i, j)]</span><br><span class="line">                vis[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> cur:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = []</span><br><span class="line">                    <span class="keyword">for</span> x0, y0 <span class="keyword">in</span> pre:</span><br><span class="line">                        cc += <span class="number">1</span></span><br><span class="line">                        x = x0 * n + y0</span><br><span class="line">                        fx = find(x)</span><br><span class="line">                        <span class="keyword">for</span> x1, y1 <span class="keyword">in</span> (x0 + <span class="number">1</span>, y0), (x0 - <span class="number">1</span>, y0), (x0, y0 + <span class="number">1</span>), (x0, y0 - <span class="number">1</span>):</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= x1 &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y1 &lt; n <span class="keyword">and</span> vis[x1][y1] == <span class="number">0</span> <span class="keyword">and</span> grid[x1][y1] == <span class="number">1</span>:</span><br><span class="line">                                y = x1 * n + y1</span><br><span class="line">                                g[x].append(y)</span><br><span class="line">                                g[y].append(x)</span><br><span class="line">                                fy = find(y)</span><br><span class="line">                                fa[fy] = fx</span><br><span class="line">                                cur.append((x1, y1))</span><br><span class="line">                    cur = <span class="built_in">list</span>(<span class="built_in">set</span>(cur))</span><br><span class="line">                    <span class="keyword">for</span> x, y <span class="keyword">in</span> cur:</span><br><span class="line">                        vis[x][y] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        st = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    st.add(find(i * n + j))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(st) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cc == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># tarjan</span></span><br><span class="line">        t = TARJAN(m*n, g)</span><br><span class="line">        t.tarjan(<span class="built_in">list</span>(st)[<span class="number">0</span>], -<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> t.flag) <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TARJAN</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span>, g: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="comment"># 记录结点的当前时间戳和最早时间戳,从根开始的一条路径上dfn 严格递增，low 严格非降</span></span><br><span class="line">        self.dfn = [-<span class="number">1</span>] * n</span><br><span class="line">        self.low = [-<span class="number">1</span>] * n</span><br><span class="line">        self.bridge = []  <span class="comment"># 桥</span></span><br><span class="line">        self.flag = [<span class="literal">False</span>] * n  <span class="comment"># 是否是割点</span></span><br><span class="line">        self.g = g</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tarjan</span>(<span class="params">self, o: <span class="built_in">int</span>, f: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.dfn[o] = t</span><br><span class="line">        self.low[o] = t</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.g[o]:</span><br><span class="line">            <span class="keyword">if</span> child != f:</span><br><span class="line">                <span class="keyword">if</span> self.dfn[child] == -<span class="number">1</span>:</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">                    self.tarjan(child, o, t + <span class="number">1</span>)</span><br><span class="line">                    self.low[o] = <span class="built_in">min</span>(self.low[o], self.low[child])</span><br><span class="line">                    <span class="comment"># 找到割点, 非root,有儿子</span></span><br><span class="line">                    <span class="keyword">if</span> self.dfn[o] &lt;= self.low[child] <span class="keyword">and</span> f != -<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> self.flag[o]:</span><br><span class="line">                        self.flag[o] = <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 找到桥</span></span><br><span class="line">                    <span class="keyword">if</span> self.dfn[o] &lt; self.low[child]:</span><br><span class="line">                        self.bridge.append([o, child])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.low[o] = <span class="built_in">min</span>(self.low[o], self.dfn[child])</span><br><span class="line">        <span class="comment"># root点 儿子数大于等于2</span></span><br><span class="line">        <span class="keyword">if</span> f == -<span class="number">1</span> <span class="keyword">and</span> c &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> self.flag[o]:</span><br><span class="line">            self.flag[o] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序">拓扑排序</h2>
<h3 id="给定条件下构造矩阵">2392. 给定条件下构造矩阵</h3>
<p>给你一个 <strong>正</strong> 整数 <code>k</code> ，同时给你：</p>
<ul>
<li>一个大小为 <code>n</code> 的二维整数数组 <code>rowConditions</code> ，其中 <code>rowConditions[i] = [abovei, belowi]</code> 和<br />
</li>
<li>一个大小为 <code>m</code> 的二维整数数组 <code>colConditions</code> ，其中 <code>colConditions[i] = [lefti, righti]</code> 。</li>
</ul>
<p>两个数组里的整数都是 <code>1</code> 到 <code>k</code> 之间的数字。</p>
<p>你需要构造一个 <code>k x k</code> 的矩阵，<code>1</code> 到 <code>k</code> 每个数字需要 <strong>恰好出现一次</strong> 。剩余的数字都是 <code>0</code> 。</p>
<p>矩阵还需要满足以下条件：</p>
<ul>
<li>对于所有 <code>0</code> 到 <code>n - 1</code> 之间的下标 <code>i</code> ，数字 <code>abovei</code> 所在的 <strong>行</strong> 必须在数字 <code>belowi</code> 所在行的上面。<br />
</li>
<li>对于所有 <code>0</code> 到 <code>m - 1</code> 之间的下标 <code>i</code> ，数字 <code>lefti</code> 所在的 <strong>列</strong> 必须在数字 <code>righti</code> 所在列的左边。</li>
</ul>
<p>返回满足上述要求的 <strong>任意</strong> 矩阵。如果不存在答案，返回一个空的矩阵。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png" /></p>
<p><strong>输入：</strong>k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]<br />
<strong>输出：</strong>[[3,0,0],[0,0,1],[0,2,0]]<br />
<strong>解释：</strong>上图为一个符合所有条件的矩阵。<br />
行要求如下：<br />
- 数字 1 在第 <strong>1</strong> 行，数字 2 在第 <strong>2</strong> 行，1 在 2 的上面。<br />
- 数字 3 在第 <strong>0</strong> 行，数字 2 在第 <strong>2</strong> 行，3 在 2 的上面。<br />
列要求如下：<br />
- 数字 2 在第 <strong>1</strong> 列，数字 1 在第 <strong>2</strong> 列，2 在 1 的左边。<br />
- 数字 3 在第 <strong>0</strong> 列，数字 2 在第 <strong>1</strong> 列，3 在 2 的左边。<br />
注意，可能有多种正确的答案。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]<br />
<strong>输出：</strong>[]<br />
<strong>解释：</strong>由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。<br />
没有符合条件的矩阵存在，所以我们返回空矩阵。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= k &lt;= 400</code></li>
<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 104</code></li>
<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>
<li><code>1 &lt;= abovei, belowi, lefti, righti &lt;= k</code></li>
<li><code>abovei != belowi</code></li>
<li><code>lefti != righti</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/build-a-matrix-with-conditions/description/">https://leetcode.cn/problems/build-a-matrix-with-conditions/description/</a></p>
<p>可以回想之前课程表那些题, 也是拓扑排序.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildMatrix</span>(<span class="params">self, k: <span class="built_in">int</span>, rowConditions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], colConditions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">toposort</span>(<span class="params">edges</span>):</span><br><span class="line">            graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">            in_deg = [<span class="number">0</span>] * k</span><br><span class="line">            <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">                graph[u-<span class="number">1</span>].append(v-<span class="number">1</span>)</span><br><span class="line">                in_deg[v-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            order = []</span><br><span class="line">            q = deque(i <span class="keyword">for</span> i, u <span class="keyword">in</span> <span class="built_in">enumerate</span>(in_deg) <span class="keyword">if</span> u == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                order.append(node)</span><br><span class="line">                <span class="keyword">for</span> target <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    in_deg[target] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> in_deg[target] == <span class="number">0</span>:</span><br><span class="line">                        q.append(target)</span><br><span class="line">            <span class="keyword">return</span> order <span class="keyword">if</span> <span class="built_in">len</span>(order) == k <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        row = toposort(rowConditions)</span><br><span class="line">        col = toposort(colConditions)</span><br><span class="line">        <span class="keyword">if</span> row <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> col <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        pos = &#123;x:i <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(col)&#125;</span><br><span class="line">        ans = [[<span class="number">0</span>] * k <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            ans[i][pos[x]] = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="floyd算法">floyd算法</h2>
<h3 id="关闭分部的可行集合数目">2959. 关闭分部的可行集合数目</h3>
<p>一个公司在全国有 <code>n</code> 个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达。</p>
<p>公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（<strong>也可能不关闭任何分部</strong>），同时保证剩下的分部之间两两互相可以到达且最远距离不超过 <code>maxDistance</code> 。</p>
<p>两个分部之间的 <strong>距离</strong> 是通过道路长度之和的 <strong>最小值</strong> 。</p>
<p>给你整数 <code>n</code> ，<code>maxDistance</code> 和下标从 <strong>0</strong> 开始的二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [ui, vi, wi]</code> 表示一条从 <code>ui</code> 到 <code>vi</code> 长度为 <code>wi</code>的 <strong>无向</strong> 道路。</p>
<p>请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过 <code>maxDistance</code>。</p>
<p><strong>注意</strong>，关闭一个分部后，与之相连的所有道路不可通行。</p>
<p><strong>注意</strong>，两个分部之间可能会有多条道路。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/11/08/example11.png" /></p>
<p><strong>输入：</strong>n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]<br />
<strong>输出：</strong>5<br />
<strong>解释：</strong>可行的关闭分部方案有：<br />
- 关闭分部集合 [2] ，剩余分部为 [0,1] ，它们之间的距离为 2 。<br />
- 关闭分部集合 [0,1] ，剩余分部为 [2] 。<br />
- 关闭分部集合 [1,2] ，剩余分部为 [0] 。<br />
- 关闭分部集合 [0,2] ，剩余分部为 [1] 。<br />
- 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。<br />
总共有 5 种可行的关闭方案。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/11/08/example22.png" /></p>
<p><strong>输入：</strong>n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]<br />
<strong>输出：</strong>7<br />
<strong>解释：</strong>可行的关闭分部方案有：<br />
- 关闭分部集合 [] ，剩余分部为 [0,1,2] ，它们之间的最远距离为 4 。<br />
- 关闭分部集合 [0] ，剩余分部为 [1,2] ，它们之间的距离为 2 。<br />
- 关闭分部集合 [1] ，剩余分部为 [0,2] ，它们之间的距离为 2 。<br />
- 关闭分部集合 [0,1] ，剩余分部为 [2] 。<br />
- 关闭分部集合 [1,2] ，剩余分部为 [0] 。<br />
- 关闭分部集合 [0,2] ，剩余分部为 [1] 。<br />
- 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。<br />
总共有 7 种可行的关闭方案。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>n = 1, maxDistance = 10, roads = []<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong>可行的关闭分部方案有：<br />
- 关闭分部集合 [] ，剩余分部为 [0] 。<br />
- 关闭分部集合 [0] ，关闭后没有剩余分部。<br />
总共有 2 种可行的关闭方案。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>1 &lt;= maxDistance &lt;= 105</code></li>
<li><code>0 &lt;= roads.length &lt;= 1000</code></li>
<li><code>roads[i].length == 3</code></li>
<li><code>0 &lt;= ui, vi &lt;= n - 1</code></li>
<li><code>ui != vi</code></li>
<li><code>1 &lt;= wi &lt;= 1000</code></li>
<li>一开始所有分部之间通过道路互相可以到达。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/description/?envType=daily-question&amp;envId=2024-07-21">https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/description/?envType=daily-question&amp;envId=2024-07-21</a></p>
<p>生成所有可能组合, 然后对所有组合做floyd求出最大的最短路径. 非常暴力, 但是floyd板子可以看下.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">floyd</span>(<span class="params">self, node_lst, graph</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(node_lst) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        shortest = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        d = copy.deepcopy(graph)</span><br><span class="line">        <span class="keyword">for</span> mid <span class="keyword">in</span> node_lst:</span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> node_lst:</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> node_lst:</span><br><span class="line">                    <span class="keyword">if</span> d[u][v] &gt; d[u][mid] + d[mid][v]:</span><br><span class="line">                        d[u][v] = d[u][mid] + d[mid][v]</span><br><span class="line">                        d[v][u] = d[u][v]</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> node_lst:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> node_lst:</span><br><span class="line">                <span class="keyword">if</span> d[u][v] &gt; shortest:</span><br><span class="line">                    shortest = d[u][v]</span><br><span class="line">        <span class="keyword">del</span> d</span><br><span class="line">        <span class="keyword">return</span> shortest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfSets</span>(<span class="params">self, n: <span class="built_in">int</span>, maxDistance: <span class="built_in">int</span>, roads: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        graph = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            graph[i][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> roads:</span><br><span class="line">            dis = <span class="built_in">min</span>(w, graph[u][v])</span><br><span class="line">            graph[u][v] = dis</span><br><span class="line">            graph[v][u] = dis</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** n):</span><br><span class="line">            node_lst = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> (i &gt;&gt; j) &amp; <span class="number">1</span>]</span><br><span class="line">            shortest = self.floyd(node_lst, graph)</span><br><span class="line">            <span class="keyword">if</span> shortest &lt;= maxDistance:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="阈值距离内邻居最少的城市">1334. 阈值距离内邻居最少的城市</h3>
<p>有 <code>n</code> 个城市，按从 <code>0</code> 到 <code>n-1</code> 编号。给你一个边数组 <code>edges</code>，其中 <code>edges[i] = [fromi, toi, weighti]</code> 代表 <code>fromi</code> 和 <code>toi</code> 两个城市之间的双向加权边，距离阈值是一个整数 <code>distanceThreshold</code>。</p>
<p>返回在路径距离限制为 <code>distanceThreshold</code> 以内可到达城市最少的城市。如果有多个这样的城市，则返回编号最大的城市。</p>
<p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png" /></p>
<p><strong>输入：</strong>n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4<br />
<strong>输出：</strong>3<br />
<strong>解释：</strong>城市分布图如上。<br />
每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：<br />
城市 0 -&gt; [城市 1, 城市 2] <br />
城市 1 -&gt; [城市 0, 城市 2, 城市 3] <br />
城市 2 -&gt; [城市 0, 城市 1, 城市 3] <br />
城市 3 -&gt; [城市 1, 城市 2] <br />
城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。</p>
<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png" /></strong></p>
<p><strong>输入：</strong>n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2<br />
<strong>输出：</strong>0<br />
<strong>解释：</strong>城市分布图如上。 <br />
每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：<br />
城市 0 -&gt; [城市 1] <br />
城市 1 -&gt; [城市 0, 城市 4] <br />
城市 2 -&gt; [城市 3, 城市 4] <br />
城市 3 -&gt; [城市 2, 城市 4]<br />
城市 4 -&gt; [城市 1, 城市 2, 城市 3] <br />
城市 0 在阈值距离 2 以内只有 1 个邻居城市。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>0 &lt;= fromi &lt; toi &lt; n</code></li>
<li><code>1 &lt;= weighti, distanceThreshold &lt;= 10^4</code></li>
<li>所有 <code>(fromi, toi)</code> 都是不同的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/">https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/</a></p>
<p>floyd和dijkstra都可以.</p>
<p>floyd写法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">floyd</span>(<span class="params">self, graph, n</span>):</span><br><span class="line">        <span class="keyword">for</span> mid <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> graph[u][v] &gt; graph[u][mid] + graph[mid][v]:</span><br><span class="line">                        graph[u][v] = graph[u][mid] + graph[mid][v]</span><br><span class="line">                        graph[v][u] = graph[u][v]</span><br><span class="line">        <span class="keyword">return</span> graph</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheCity</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], distanceThreshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        graph = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            graph[i][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u,v,w <span class="keyword">in</span> edges:</span><br><span class="line">            graph[u][v] = w</span><br><span class="line">            graph[v][u] = w</span><br><span class="line">        </span><br><span class="line">        graph = self.floyd(graph, n)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        min_count = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            curr = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">if</span> x &lt;= distanceThreshold <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> graph[u])</span><br><span class="line">            <span class="keyword">if</span> curr &lt;= min_count:</span><br><span class="line">                min_count = curr</span><br><span class="line">                ans = u</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>dijkstra写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">self, graph, u, n</span>):</span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        ans[u] = <span class="number">0</span></span><br><span class="line">        q = [(<span class="number">0</span>,u)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            w, v = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">if</span> w &gt; ans[v]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> node, weight <span class="keyword">in</span> <span class="built_in">enumerate</span>(graph[v]):</span><br><span class="line">                new_dist = weight + w</span><br><span class="line">                <span class="keyword">if</span> ans[node] &gt; new_dist <span class="keyword">or</span> ans[node] &lt; <span class="number">0</span>:</span><br><span class="line">                    ans[node] = new_dist</span><br><span class="line">                    heapq.heappush(q, (new_dist, node))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheCity</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], distanceThreshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        graph = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            graph[i][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u,v,w <span class="keyword">in</span> edges:</span><br><span class="line">            graph[u][v] = w</span><br><span class="line">            graph[v][u] = w</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        min_count = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            lst = self.dijkstra(graph, u, n)</span><br><span class="line">            curr = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">if</span> x &lt;= distanceThreshold <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> lst)</span><br><span class="line">            <span class="keyword">if</span> curr &lt;= min_count:</span><br><span class="line">                min_count = curr</span><br><span class="line">                ans = u</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra算法">dijkstra算法</h2>
<h3 id="访问消失节点的最少时间">3112. 访问消失节点的最少时间</h3>
<p>给你一个二维数组 <code>edges</code> 表示一个 <code>n</code> 个点的无向图，其中 <code>edges[i] = [ui, vi, lengthi]</code> 表示节点 <code>ui</code> 和节点 <code>vi</code> 之间有一条需要 <code>lengthi</code> 单位时间通过的无向边。</p>
<p>同时给你一个数组 <code>disappear</code> ，其中 <code>disappear[i]</code> 表示节点 <code>i</code> 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。</p>
<p><strong>注意</strong>，图有可能一开始是不连通的，两个节点之间也可能有多条边。</p>
<p>请你返回数组 <code>answer</code> ，<code>answer[i]</code> 表示从节点 <code>0</code> 到节点 <code>i</code> 需要的 <strong>最少</strong> 单位时间。如果从节点 <code>0</code> 出发 <strong>无法</strong> 到达节点 <code>i</code> ，那么 <code>answer[i]</code> 为 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/03/09/example1.png" /></p>
<p><strong>输入：</strong>n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]</p>
<p><strong>输出：</strong>[0,-1,4]</p>
<p><strong>解释：</strong></p>
<p>我们从节点 0 出发，目的是用最少的时间在其他节点消失之前到达它们。</p>
<ul>
<li>对于节点 0 ，我们不需要任何时间，因为它就是我们的起点。<br />
</li>
<li>对于节点 1 ，我们需要至少 2 单位时间，通过 <code>edges[0]</code> 到达。但当我们到达的时候，它已经消失了，所以我们无法到达它。<br />
</li>
<li>对于节点 2 ，我们需要至少 4 单位时间，通过 <code>edges[2]</code> 到达。</li>
</ul>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/03/09/example2.png" /></p>
<p><strong>输入：</strong>n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]</p>
<p><strong>输出：</strong>[0,2,3]</p>
<p><strong>解释：</strong></p>
<p>我们从节点 0 出发，目的是用最少的时间在其他节点消失之前到达它们。</p>
<ul>
<li>对于节点 0 ，我们不需要任何时间，因为它就是我们的起点。<br />
</li>
<li>对于节点 1 ，我们需要至少 2 单位时间，通过 <code>edges[0]</code> 到达。<br />
</li>
<li>对于节点 2 ，我们需要至少 3 单位时间，通过 <code>edges[0]</code> 和 <code>edges[1]</code> 到达。</li>
</ul>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>n = 2, edges = [[0,1,1]], disappear = [1,1]</p>
<p><strong>输出：</strong>[0,-1]</p>
<p><strong>解释：</strong></p>
<p>当我们到达节点 1 的时候，它恰好消失，所以我们无法到达节点 1 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>0 &lt;= edges.length &lt;= 105</code></li>
<li><code>edges[i] == [ui, vi, lengthi]</code></li>
<li><code>0 &lt;= ui, vi &lt;= n - 1</code></li>
<li><code>1 &lt;= lengthi &lt;= 105</code></li>
<li><code>disappear.length == n</code></li>
<li><code>1 &lt;= disappear[i] &lt;= 105</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/description/?envType=daily-question&amp;envId=2024-07-21">https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/description/?envType=daily-question&amp;envId=2024-07-21</a></p>
<p>比较基础的dijkstra.</p>
<ol type="1">
<li>存graph<br />
</li>
<li>初始化ans全-1<br />
</li>
<li>初始化queue为(0,0), 每次用优先队列取(distance, node)<br />
</li>
<li>循环读queue, 且将读取的节点当中间节点来更新ans<br />
</li>
<li>返回ans</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTime</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], disappear: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        graph = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> u,v,w <span class="keyword">in</span> edges:</span><br><span class="line">            graph[u].append([v,w])</span><br><span class="line">            graph[v].append([u,w])</span><br><span class="line">        </span><br><span class="line">        ans = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># distance, target</span></span><br><span class="line">        q = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            dist, target = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">if</span> dist &gt; ans[target]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> node, weight <span class="keyword">in</span> graph[target]:</span><br><span class="line">                new_dist = dist + weight</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt; disappear[node] <span class="keyword">and</span> (new_dist &lt; ans[node] <span class="keyword">or</span> ans[node] &lt; <span class="number">0</span>):</span><br><span class="line">                    ans[node] = new_dist</span><br><span class="line">                    heapq.heappush(q, (new_dist, node))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="到达目的地的第二短时间">2045. 到达目的地的第二短时间</h3>
<p>城市用一个 <strong>双向连通</strong> 图表示，图中有 <code>n</code> 个节点，从 <code>1</code> 到 <code>n</code> 编号（包含 <code>1</code> 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [ui, vi]</code> 表示一条节点 <code>ui</code> 和节点 <code>vi</code> 之间的双向连通边。每组节点对由 <strong>最多一条</strong> 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code> 分钟。</p>
<p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 <strong>同时</strong> 改变。你可以在 <strong>任何时候</strong> 进入某个节点，但是 <strong>只能</strong> 在节点 <strong>信号灯是绿色时</strong> 才能离开。如果信号灯是  <strong>绿色</strong> ，你 <strong>不能</strong> 在节点等待，必须离开。</p>
<p><strong>第二小的值</strong> 是 <strong>严格大于</strong> 最小值的所有值中最小的值。</p>
<ul>
<li>例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 <code>4</code> 。</li>
</ul>
<p>给你 <code>n</code>、<code>edges</code>、<code>time</code> 和 <code>change</code> ，返回从节点 <code>1</code> 到节点 <code>n</code> 需要的 <strong>第二短时间</strong> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>你可以 <strong>任意次</strong> 穿过任意顶点，<strong>包括</strong> <code>1</code> 和 <code>n</code> 。<br />
</li>
<li>你可以假设在 <strong>启程时</strong> ，所有信号灯刚刚变成 <strong>绿色</strong> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/29/e1.png" />        </p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/29/e2.png" /></p>
<p><strong>输入：</strong>n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5<br />
<strong>输出：</strong>13<br />
<strong>解释：</strong><br />
上面的左图展现了给出的城市交通图。<br />
右图中的蓝色路径是最短时间路径。<br />
花费的时间是：<br />
- 从节点 1 开始，总花费时间=0<br />
- 1 -&gt; 4：3 分钟，总花费时间=3<br />
- 4 -&gt; 5：3 分钟，总花费时间=6<br />
因此需要的最小时间是 6 分钟。</p>
<p>右图中的红色路径是第二短时间路径。<br />
- 从节点 1 开始，总花费时间=0<br />
- 1 -&gt; 3：3 分钟，总花费时间=3<br />
- 3 -&gt; 4：3 分钟，总花费时间=6<br />
- 在节点 4 等待 4 分钟，总花费时间=10<br />
- 4 -&gt; 5：3 分钟，总花费时间=13<br />
因此第二短时间是 13 分钟。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/29/eg2.png" /></p>
<p><strong>输入：</strong>n = 2, edges = [[1,2]], time = 3, change = 2<br />
<strong>输出：</strong>11<br />
<strong>解释：</strong><br />
最短时间路径是 1 -&gt; 2 ，总花费时间 = 3 分钟<br />
第二短时间路径是 1 -&gt; 2 -&gt; 1 -&gt; 2 ，总花费时间 = 11 分钟</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 104</code></li>
<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 104, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= ui, vi &lt;= n</code></li>
<li><code>ui != vi</code></li>
<li>不含重复边</li>
<li>每个节点都可以从其他节点直接或者间接到达</li>
<li><code>1 &lt;= time, change &lt;= 103</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/second-minimum-time-to-reach-destination/description/">https://leetcode.cn/problems/second-minimum-time-to-reach-destination/description/</a></p>
<p>单源次短路径, 还是dijkstra, 不过最短路径开两个, 同时注意循环回路, 取消visited的使用, 改为一旦路径更新就入堆.</p>
<blockquote>
<p>//https://leetcode.cn/problems/second-minimum-time-to-reach-destination/solutions/1229095/gong-shui-san-xie-yi-ti-shuang-jie-dui-y-88np/<br />
维护次短路是容易的，基本思路为：<br />
- 若当前距离 dist 小于 dist1[x]，原本的最短路 dist1[x] 沦为次短路 dist2[x]，即先用 dist1[x] 更新 dist2[x] 后，再用 dist 更新 dist1[x]；<br />
- 若当前距离 dist 等于 dist1[x]，不符合「严格次短路」，忽略；<br />
- 若当前距离 dist 大于 dist1[x]，且 dist 小于 dist2[x]，则使用 dist 更新 dist2[x]。<br />
- 同时，由于处理「严格次短路包含重复边」的情况，我们无须使用 vis[] 数组记录处理过的点，而要确保每次「最短路」或者「次短路」被更新时，都进行入堆操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">secondMinimum</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], time: <span class="built_in">int</span>, change: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">            ans = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            q = [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">            <span class="keyword">while</span> ans[-<span class="number">1</span>][-<span class="number">1</span>] == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">                dist, u = heapq.heappop(q)</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">                    <span class="keyword">if</span> ans[v][<span class="number">0</span>] &gt; dist + <span class="number">1</span>:</span><br><span class="line">                        ans[v][<span class="number">1</span>] = ans[v][<span class="number">0</span>]</span><br><span class="line">                        ans[v][<span class="number">0</span>] = dist + <span class="number">1</span></span><br><span class="line">                        heapq.heappush(q, (dist+<span class="number">1</span>, v))</span><br><span class="line">                    <span class="keyword">elif</span> ans[v][<span class="number">0</span>] &lt; dist + <span class="number">1</span> &lt; ans[v][<span class="number">1</span>]:</span><br><span class="line">                        ans[v][<span class="number">1</span>] = dist + <span class="number">1</span></span><br><span class="line">                        heapq.heappush(q, (dist+<span class="number">1</span>, v)) </span><br><span class="line">            <span class="keyword">return</span> ans[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            graph[x-<span class="number">1</span>].append(y-<span class="number">1</span>)</span><br><span class="line">            graph[y-<span class="number">1</span>].append(x-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        step = dijkstra()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">            <span class="keyword">if</span> ans % (change * <span class="number">2</span>) &gt;= change:</span><br><span class="line">                ans += change * <span class="number">2</span> - ans % (change * <span class="number">2</span>)</span><br><span class="line">            ans += time</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="bitset">bitset</h1>
<h2 id="简单遍历题">简单遍历题</h2>
<h3 id="引爆最多的炸弹">2101. 引爆最多的炸弹</h3>
<p>给你一个炸弹列表。一个炸弹的 <strong>爆炸范围</strong> 定义为以炸弹为圆心的一个圆。</p>
<p>炸弹用一个下标从 <strong>0</strong> 开始的二维整数数组 <code>bombs</code> 表示，其中 <code>bombs[i] = [xi, yi, ri]</code> 。<code>xi</code> 和 <code>yi</code> 表示第 <code>i</code> 个炸弹的 X 和 Y 坐标，<code>ri</code> 表示爆炸范围的 <strong>半径</strong> 。</p>
<p>你需要选择引爆 <strong>一个</strong> 炸弹。当这个炸弹被引爆时，<strong>所有</strong> 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p>
<p>给你数组 <code>bombs</code> ，请你返回在引爆 <strong>一个</strong> 炸弹的前提下，<strong>最多</strong> 能引爆的炸弹数目。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png" /></p>
<p><strong>输入：</strong>bombs = [[2,1,3],[6,1,4]]<br />
<strong>输出：</strong>2<br />
<strong>解释：</strong><br />
上图展示了 2 个炸弹的位置和爆炸范围。<br />
如果我们引爆左边的炸弹，右边的炸弹不会被影响。<br />
但如果我们引爆右边的炸弹，两个炸弹都会爆炸。<br />
所以最多能引爆的炸弹数目是 max(1, 2) = 2 。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png" /></p>
<p><strong>输入：</strong>bombs = [[1,1,5],[10,10,5]]<br />
<strong>输出：</strong>1<br />
<strong>解释：</strong><br />
引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。</p>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png" /></p>
<p><strong>输入：</strong>bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]<br />
<strong>输出：</strong>5<br />
<strong>解释：</strong><br />
最佳引爆炸弹为炸弹 0 ，因为：<br />
- 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。<br />
- 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。<br />
- 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。<br />
所以总共有 5 个炸弹被引爆。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= bombs.length &lt;= 100</code></li>
<li><code>bombs[i].length == 3</code></li>
<li><code>1 &lt;= xi, yi, ri &lt;= 105</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/detonate-the-maximum-bombs/description/?envType=daily-question&amp;envId=2024-07-21">https://leetcode.cn/problems/detonate-the-maximum-bombs/description/?envType=daily-question&amp;envId=2024-07-21</a></p>
<p><strong>bfs做法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumDetonation</span>(<span class="params">self, bombs: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        source_target = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        center = [(x,y) <span class="keyword">for</span> x,y,r <span class="keyword">in</span> bombs]</span><br><span class="line">        ctr = Counter(center)</span><br><span class="line">        center = <span class="built_in">set</span>(center)</span><br><span class="line">        <span class="keyword">for</span> x,y,r <span class="keyword">in</span> bombs:</span><br><span class="line">            <span class="keyword">for</span> cx, cy <span class="keyword">in</span> center:</span><br><span class="line">                <span class="keyword">if</span> (x-cx) ** <span class="number">2</span> + (y-cy) ** <span class="number">2</span> &lt;= r ** <span class="number">2</span>:</span><br><span class="line">                    source_target[(x,y)].add((cx,cy))</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> center:</span><br><span class="line">            x, y = center.pop()</span><br><span class="line">            curr = ctr[(x,y)]</span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line">            visited.add((x,y))</span><br><span class="line">            stack = <span class="built_in">set</span>()</span><br><span class="line">            stack.add((x,y))</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                x, y = stack.pop()</span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> source_target[(x,y)]:</span><br><span class="line">                    <span class="keyword">if</span> (nx,ny) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        stack.add((nx,ny))</span><br><span class="line">                        visited.add((nx,ny))</span><br><span class="line">                        curr += ctr[(nx,ny)]</span><br><span class="line">                        center -= &#123;(nx,ny)&#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>bitset做法, f存的数字的二进制位数表示了可以引爆的数量, 解法蛮暴力的.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumDetonation</span>(<span class="params">self, bombs: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(bombs)</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i, (x, y, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(bombs):</span><br><span class="line">            <span class="keyword">for</span> j, (x2, y2, _) <span class="keyword">in</span> <span class="built_in">enumerate</span>(bombs):</span><br><span class="line">                dx = x - x2</span><br><span class="line">                dy = y - y2</span><br><span class="line">                <span class="keyword">if</span> dx * dx + dy * dy &lt;= r * r:</span><br><span class="line">                    f[i] |= <span class="number">1</span> &lt;&lt; j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> f[i] &gt;&gt; k &amp; <span class="number">1</span>:</span><br><span class="line">                    f[i] |= f[k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(s.bit_count() <span class="keyword">for</span> s <span class="keyword">in</span> f)</span><br></pre></td></tr></table></figure>
<h2 id="dp题">dp题</h2>
<h3 id="执行操作可获得的最大总奖励-ii">3181. 执行操作可获得的最大总奖励 II</h3>
<p>给你一个整数数组 <code>rewardValues</code>，长度为 <code>n</code>，代表奖励的值。</p>
<p>最初，你的总奖励 <code>x</code> 为 0，所有下标都是 <strong>未标记</strong> 的。你可以执行以下操作 <strong>任意次</strong> ：</p>
<ul>
<li>从区间 <code>[0, n - 1]</code> 中选择一个 <strong>未标记</strong> 的下标 <code>i</code>。<br />
</li>
<li>如果 <code>rewardValues[i]</code> <strong>大于</strong> 你当前的总奖励 <code>x</code>，则将 <code>rewardValues[i]</code> 加到 <code>x</code> 上（即 <code>x = x + rewardValues[i]</code>），并 <strong>标记</strong> 下标 <code>i</code>。</li>
</ul>
<p>以整数形式返回执行最优操作能够获得的 <strong>最大</strong> 总奖励。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>rewardValues = [1,1,3,3]</p>
<p><strong>输出：</strong>4</p>
<p><strong>解释：</strong></p>
<p>依次标记下标 0 和 2，总奖励为 4，这是可获得的最大值。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>rewardValues = [1,6,4,3,2]</p>
<p><strong>输出：</strong>11</p>
<p><strong>解释：</strong></p>
<p>依次标记下标 0、2 和 1。总奖励为 11，这是可获得的最大值。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= rewardValues.length &lt;= 5 * 104</code><br />
</li>
<li><code>1 &lt;= rewardValues[i] &lt;= 5 * 104</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/">https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/</a></p>
<p>这题在dp里面也记录了下, 因为状态转移是直接平移, 所以可以用bit来做, 进行一个计算加速同时节省空间.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTotalReward</span>(<span class="params">self, rewardValues: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        f = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(rewardValues)):</span><br><span class="line">            f |= (f &amp; ((<span class="number">1</span>&lt;&lt;v)-<span class="number">1</span>)) &lt;&lt; v</span><br><span class="line">        <span class="keyword">return</span> f.bit_length() - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="数位dp">数位dp</h2>
<h3 id="不含连续1的非负整数">600. 不含连续1的非负整数</h3>
<p>给定一个正整数 <code>n</code> ，请你统计在 <code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1</strong> 。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> n = 5<br />
<strong>输出:</strong> 5<br />
<strong>解释:</strong><br />
下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：<br />
0 : 0<br />
1 : 1<br />
2 : 10<br />
3 : 11<br />
4 : 100<br />
5 : 101<br />
其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> n = 1<br />
<strong>输出:</strong> 2</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> n = 2<br />
<strong>输出:</strong> 3</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 109</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/description/?envType=daily-question&amp;envId=2024-08-05">https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/description/?envType=daily-question&amp;envId=2024-08-05</a></p>
<p>暴力肯定是不行的, 想了一下发现后状态和前状态有关, 所以一开始写了个移位的bit set写法, 但是因为最后统计数量用到了bit_count,复杂度O(n)直接爆掉了. 看了下答案解法, 一种是灵神的数位dp, 另一个是官方的loop写法(其实bitset后续优化就是这个方向, 但很可惜没写出来).</p>
<p><strong>数位dp</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, prev_1, is_limit</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="comment"># 上界</span></span><br><span class="line">            up = (n &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="comment"># 填0</span></span><br><span class="line">            res = dfs(i-<span class="number">1</span>, <span class="literal">False</span>, is_limit <span class="keyword">and</span> up == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prev_1 <span class="keyword">and</span> up == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 填1</span></span><br><span class="line">                res += dfs(i-<span class="number">1</span>, <span class="literal">True</span>, is_limit)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># bit_length和索引i差1, 所以减掉1</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n.bit_length()-<span class="number">1</span>, <span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>bitset(TLE)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VALUE = <span class="number">7</span></span><br><span class="line">count = <span class="number">4</span></span><br><span class="line">lgn = <span class="number">29</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lgn - <span class="number">1</span>):</span><br><span class="line">    VALUE |= (VALUE &amp; ((<span class="number">1</span> &lt;&lt; (count &gt;&gt; <span class="number">1</span>)) - <span class="number">1</span>)) &lt;&lt; count</span><br><span class="line">    count *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="comment"># 0,1,2满足,3不满足,所以是0111,即7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (((<span class="number">1</span>&lt;&lt;(n+<span class="number">1</span>)) - <span class="number">1</span>) &amp; VALUE).bit_count()</span><br></pre></td></tr></table></figure>
<p>官方优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">31</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            val = (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">            <span class="keyword">if</span> n &amp; val:</span><br><span class="line">                res += dp[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> pre == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                pre = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8818%E5%8F%8C%E5%91%A8%E8%B5%9B"><span class="toc-number">1.</span> <span class="toc-text">8月18双周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E4%B8%89%E4%B8%AA%E8%BD%A6%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7-ii"><span class="toc-number">1.1.</span> <span class="toc-text">100401. 放三个车的价值之和最大 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8818%E5%91%A8%E8%B5%9B"><span class="toc-number">2.</span> <span class="toc-text">8月18周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D-k-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">100409. 找出最大的 N 位 K 回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%BB%A1%E8%B6%B3-k-%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E9%87%8F-ii"><span class="toc-number">2.2.</span> <span class="toc-text">100404. 统计满足 K 约束的子字符串数量 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8811%E5%91%A8%E8%B5%9B"><span class="toc-number">3.</span> <span class="toc-text">8月11周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">3.1.</span> <span class="toc-text">100354. 统计好节点的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%95%B0%E7%BB%84%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE-ii"><span class="toc-number">3.2.</span> <span class="toc-text">100396. 单调数组对的数目 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%884%E5%91%A8%E8%B5%9B"><span class="toc-number">4.</span> <span class="toc-text">8月4周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB-i"><span class="toc-number">4.1.</span> <span class="toc-text">100379. 新增道路查询后的最短距离 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB-ii"><span class="toc-number">4.2.</span> <span class="toc-text">100376. 新增道路查询后的最短距离 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E7%BB%84-iii"><span class="toc-number">4.3.</span> <span class="toc-text">3245. 交替组 III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8828%E5%91%A8%E8%B5%9B"><span class="toc-number">5.</span> <span class="toc-text">7月28周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%8D%E6%98%AF%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">100371. 统计不是特殊数字的数字数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1-1-%E6%98%BE%E8%91%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">100348. 统计 1 显著的字符串的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%92%E8%90%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE"><span class="toc-number">5.3.</span> <span class="toc-text">100347. 判断矩形的两个角落是否可达</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">1395. 统计作战单位数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%89%E8%90%BD%E7%9A%84%E6%96%B9%E5%9D%97"><span class="toc-number">7.1.</span> <span class="toc-text">699. 掉落的方块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">差分数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E8%BD%A6"><span class="toc-number">8.1.</span> <span class="toc-text">1094. 拼车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">100329. 使数组等于目标数组所需的最少操作次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">9.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6"><span class="toc-number">9.1.</span> <span class="toc-text">721. 账户合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number"></span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tarjan"><span class="toc-number">1.</span> <span class="toc-text">tarjan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E9%99%86%E5%9C%B0%E5%88%86%E7%A6%BB%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1568. 使陆地分离的最少天数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.</span> <span class="toc-text">2392. 给定条件下构造矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">floyd算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%88%86%E9%83%A8%E7%9A%84%E5%8F%AF%E8%A1%8C%E9%9B%86%E5%90%88%E6%95%B0%E7%9B%AE"><span class="toc-number">3.1.</span> <span class="toc-text">2959. 关闭分部的可行集合数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82"><span class="toc-number">3.2.</span> <span class="toc-text">1334. 阈值距离内邻居最少的城市</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%B6%88%E5%A4%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4"><span class="toc-number">4.1.</span> <span class="toc-text">3112. 访问消失节点的最少时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%9F%AD%E6%97%B6%E9%97%B4"><span class="toc-number">4.2.</span> <span class="toc-text">2045. 到达目的地的第二短时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bitset"><span class="toc-number"></span> <span class="toc-text">bitset</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%81%8D%E5%8E%86%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">简单遍历题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%88%86%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B8%E5%BC%B9"><span class="toc-number">1.1.</span> <span class="toc-text">2101. 引爆最多的炸弹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">dp题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-ii"><span class="toc-number">2.1.</span> <span class="toc-text">3181. 执行操作可获得的最大总奖励 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="toc-number">3.</span> <span class="toc-text">数位dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%AB%E8%BF%9E%E7%BB%AD1%E7%9A%84%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">600. 不含连续1的非负整数</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/07/21/DSA-misc/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/07/21/DSA-misc/&text=DSA-misc"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/07/21/DSA-misc/&is_video=false&description=DSA-misc"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DSA-misc&body=Check out this article: http://example.com/2024/07/21/DSA-misc/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/07/21/DSA-misc/&title=DSA-misc"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/07/21/DSA-misc/&name=DSA-misc&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/07/21/DSA-misc/&t=DSA-misc"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    blacsheep
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
